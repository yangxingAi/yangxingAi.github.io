

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Anh Tinh">
  <meta name="keywords" content="">
  
    <meta name="description" content="Flutter知识点1、什么是Flutter Flutter 是谷歌公司开发的一款开源、免费的 UI 框架，可以让我们快速的在 Android 和 iOS 上构建高质量 App。它最大的特点就是跨平台、以及高性能。 目前 Flutter 不仅可以开发跨平台的 APP 还可以开发 WEB 以及跨平台的桌面软件。虽然 Flutter 可以开发 web 网站，但是国内主要还是开发 APP，也有人用它 开">
<meta property="og:type" content="article">
<meta property="og:title" content="Anh Tinh yêu vợ">
<meta property="og:url" content="http://example.com/2024/07/31/flutter%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Anh Tinh yêu vợ">
<meta property="og:description" content="Flutter知识点1、什么是Flutter Flutter 是谷歌公司开发的一款开源、免费的 UI 框架，可以让我们快速的在 Android 和 iOS 上构建高质量 App。它最大的特点就是跨平台、以及高性能。 目前 Flutter 不仅可以开发跨平台的 APP 还可以开发 WEB 以及跨平台的桌面软件。虽然 Flutter 可以开发 web 网站，但是国内主要还是开发 APP，也有人用它 开">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-31T10:13:14.198Z">
<meta property="article:modified_time" content="2024-08-01T07:58:17.711Z">
<meta property="article:author" content="Anh Tinh">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Anh Tinh yêu vợ</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Anh Tinh</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-31 18:13" pubdate>
          2024年7月31日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          144 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Flutter知识点"><a href="#Flutter知识点" class="headerlink" title="Flutter知识点"></a><strong>Flutter</strong>知识点</h1><p><strong>1</strong>、<strong>什么是Flutter</strong></p>
<p>Flutter 是谷歌公司开发的一款开源、免费的 UI 框架，可以让我们快速的在 Android 和 iOS 上构建高质量</p>
<p>App。它最大的特点就是跨平台、以及高性能。 目前 Flutter 不仅可以开发跨平台的 APP 还可以开发</p>
<p>WEB 以及跨平台的桌面软件。虽然 Flutter 可以开发 web 网站，但是国内主要还是开发 APP，也有人用它</p>
<p>开发桌面软件。</p>
<p>2、<strong>用</strong> <strong>Flutter</strong> <strong>几年了？</strong>Flutter <strong>每个版本有什么区别？</strong></p>
<p>Flutter 每个版本的用法基本都是一样的，每隔几天或者几周就会更新一个版本，2018 年 12 月 5 日发布了</p>
<p>1.x 版本，2021 年 3 月 4 日官方发布了 2.x, 2022 年 5 月 12 日发布了 3.x 版本。</p>
<p>Flutter2.x 和 Flutter1.x 的最大区别就是 2.x 以后增加了空安全， 可以通过 <strong>?</strong> 定义可空类型 ，通过**!**实</p>
<p>现类型断言</p>
<p>Flutter2.x 的时候就支持了桌面软件开发,在 Flutter3.x 之后桌面软件开发已经非常成熟了</p>
<p>Flutter3.x 对代码有代码语法有比较严格的要求，比如写 Text 组件的时候里面数据是常量的话，需要在组</p>
<p>件前面加 Const，虽然不加 Const 代码也可以运行，但是编辑器会有提示</p>
<p>Flutter 有 Stable、Beta、Dev 和 Master 版本， Stable（稳定版）Beta（公测版）Dev（开发版）Master</p>
<p>（主分支）</p>
<p><strong>Stable</strong>（稳定版）：这是最稳定的版本，推荐用于生产环境。</p>
<p><strong>Beta</strong>（公测版）：这个版本相对较稳定，但仍有可能存在一些已知问题。</p>
<p><strong>Dev</strong>（开发版）：这个版本是经过 Google 测试后的最新版本，包含新功能和改进。</p>
<p><strong>Master</strong>（主分支）：这是最新的代码主分支，更新速度非常快，几乎每天都有提交。</p>
<p>开发的时候一般用的是正式版本。正式版本也有很多，每个版本用法都是一样的，一般用最新的更新周期</p>
<p>比较长的版本。</p>
<p>比如 2024 年 1 月的 flutter_3.16.9 发布后过了一个月才更新的下一个版本，这个版本一般就是首选版本</p>
<p>但是 2024 年 2 月发布的 flutter_3.19.0 发布后几天就又更新了一个版本，所以选择的时候尽量不选择这</p>
<p>样的版本</p>
<p><strong>4****、请简述一下</strong> <strong>Flutter</strong> <strong>的优缺点</strong></p>
<p><strong>优点：</strong></p>
<p><strong>跨平台</strong>：Flutter 可以开发 Android、iOS、Web 和桌面应用程序，一套代码可以运行在多个平台上。</p>
<p><strong>高效渲染</strong>：Flutter 使用了自己的渲染引擎，可以实现流畅的 60 帧&#x2F;秒的动画效果。</p>
<p><strong>热重载</strong>：Flutter 支持热重载，可以在运行时快速修改代码并查看效果，提高了开发效率。</p>
<p><strong>丰富的组件</strong>：Flutter 提供了丰富的内置组件，可以快速搭建用户界面。</p>
<p><strong>强大的工具链</strong>：Flutter 提供了强大的工具链，包括 Dart 编程语言、Flutter 框架和命令行工具等。</p>
<p><strong>良好的性能</strong>：Flutter 应用程序的性能较好，与原生应用程序相比差别不大。</p>
<p><strong>完善的插件库</strong>**:**有比较完善的插件库</p>
<p><strong>缺点：****学习曲线</strong>：虽然 Flutter 的文档丰富，但学习曲线较陡峭，需要花费一定的时间学习和掌握。</p>
<p><strong>与原生应用的集成</strong>：在某些情况下，与原生应用集成可能会比较复杂，需要编写一些原生代码。</p>
<p><strong>5<strong><strong>、</strong></strong>Flutter</strong> <strong>有哪些常用的</strong> <strong>Widget****？</strong></p>
<p>常用的 Widget 包括 Container 、Center、 Row 、 Column、Card、Wrap 、Stack、Padding、Flex、</p>
<p>Expanded、GridView、ListView、Image 、Text、Tabs、按钮相关、表单相关组件</p>
<p><strong>6<strong><strong>、</strong></strong>Flutter Cupertino</strong> <strong>和</strong> <strong>Material UI</strong> <strong>库区别</strong></p>
<p>Flutter Cupertino 和 Material 是 Flutter 框架中的两个设计语言和视觉风格，我们以前开发项目的时候一般</p>
<p>用 Material 。</p>
<p><strong>Cupertino</strong>：Cupertino 是苹果公司的设计语言，用于构建 iOS 风格的用户界面。Flutter 提供了一套名为</p>
<p>“cupertino” 的包，其中包含了苹果风格的 UI 组件、图标和样式。使用 Cupertino，你可以创建具有 iOS 视</p>
<p>觉效果和交互行为的应用程序，例如 iOS 设备上常见的滚动效果、导航栏样式和操作表。</p>
<p><strong>Material</strong>：Material 是 Google 的设计语言，用于构建现代、响应式和有吸引力的用户界面。Flutter 提供了</p>
<p>名为 “material” 的包，其中包含了 Material Design 风格的 UI 组件、图标和样式。使用 Material，你可以</p>
<p>创建具有 Material Design 视觉效果和交互行为的应用程序，例如漂浮按钮、卡片、阴影效果和标准的应用</p>
<p>栏。</p>
<p><strong>7****、如何自定义一个</strong> <strong>Widget</strong></p>
<p>通过继承 StatelessWidget 或 StatefulWidget，实现自己的 Widget。</p>
<p><strong>8<strong><strong>、</strong></strong>StatefulWidget</strong> <strong>和</strong> <strong>StatelessWidget</strong> <strong>什么区别</strong><strong>?</strong></p>
<p>StatelessWidget 是无状态组件，状态不可变的 widget</p>
<p>StatefulWidget 是有状态组件，持有的状态可能在 widget 生命周期改变。</p>
<p>更新 StatefulWidget 的数据通过 setState</p>
<p>setState(() {</p>
<p>});<strong>9****、解释一下</strong> <strong>Flutter</strong> <strong>中的</strong> <strong>Widge****？</strong></p>
<p>在 Flutter 中 Widget 是构成用户界面的基本元素, Container 、Center、 Row 、 Column、Card、Wrap 、</p>
<p>Stack、Padding、Flex 这些都是 Flutter 内置的 Widget</p>
<p>我们也可以自定义 Widget，继承 StatelessWidget 实现无状态组件，继承 StatefulWidget 实现有状态组</p>
<p>件</p>
<p><strong>Widget</strong> <strong>可以分为两大类：</strong></p>
<p><strong>无状态</strong>（Stateless）Widget：这类 Widget 的属性是不可变的，它们不会随时间变化。例如，一个无状态的</p>
<p>按钮，它的颜色、大小和文本等属性在生命周期中是固定的</p>
<p><strong>有状态</strong>（Stateful）Widget：这类 Widget 的属性是可以改变的，它们会随时间变化。例如，一个有状态的按</p>
<p>钮，在用户点击后，它的颜色和文本可能会发生变化。有状态 Widget 在创建后可以发生变化，例如用户交</p>
<p>互、网络请求或数据更改等</p>
<p><strong>Widget</strong> <strong>的生命周期：</strong></p>
<p>创建：当需要显示一个 Widget 时，Flutter 框架会调用其 build 方法来创建它。</p>
<p>更新：当一个有状态 Widget 的状态发生变化时，它的 build 方法会被再次调用，以便更新用户界面。</p>
<p>销毁：当一个 Widget 不再需要时，Flutter 框架会调用其 deactivate 和 dispose 方法来销毁它。 </p>
<p><strong>Widget</strong> <strong>的树形结构：</strong></p>
<p>在 Flutter 应用程序中，所有的 Widget 都会组成一棵树形结构，称为 Widget 树。Widget 树的根节点通常</p>
<p>是 MaterialApp 或 CupertinoApp，然后依次是 Scaffold、AppBar、ListView 等。这种层次结构使得 Flutter</p>
<p>可以有效地管理和渲染复杂的用户界面。</p>
<p><strong>10<strong><strong>、</strong></strong>Flutter main.dart</strong> <strong>的用途是什么</strong></p>
<p>在 Flutter 项目中，main.dart 文件是项目的入口点。它包含了应用程序的主函数，这个</p>
<p>主函数是应用程序的启动点。</p>
<p>main.dart 里面可以配置初始化代码设置状态栏、项目主题、路由、动画等，它是应用程</p>
<p>序的核心文件，用于组织和管理整个应用程序的结构和逻辑。void main() {</p>
<p>&#x2F;&#x2F;配置透明的状态栏</p>
<p>SystemUiOverlayStyle systemUiOverlayStyle &#x3D; const SystemUiOverlayStyle(statusBarColor:</p>
<p>Colors.transparent);</p>
<p>SystemChrome.setSystemUIOverlayStyle(systemUiOverlayStyle);</p>
<p>runApp(</p>
<p>ScreenUtilInit(</p>
<p>designSize: const Size(1080, 2400), </p>
<p>&#x2F;&#x2F;设计稿的宽度和高度 px</p>
<p>minTextAdapt: true, </p>
<p>splitScreenMode: true, </p>
<p>builder: (context , child) {</p>
<p>return GetMaterialApp(</p>
<p>debugShowCheckedModeBanner: false, </p>
<p>title: “Application”, </p>
<p>&#x2F;&#x2F;配置主题</p>
<p>theme: ThemeData(</p>
<p>primarySwatch: Colors.grey</p>
<p>),</p>
<p>initialRoute: AppPages.INITIAL, </p>
<p>&#x2F;&#x2F;配置 ios 动画</p>
<p>defaultTransition:Transition.rightToLeft , </p>
<p>getPages: AppPages.routes, </p>
<p>);</p>
<p>})</p>
<p>);</p>
<p>}</p>
<p><strong>11<strong><strong>、</strong></strong>Flutter</strong> <strong>项目中“<strong><strong>pubspec.yaml</strong></strong>”文件的用途是什么</strong></p>
<p>在 Flutter 项目中，pubspec.yaml 文件是项目的配置文件，它用于描述项目依赖的包</p>
<p>（Packages）、版本信息以及其他相关配置。</p>
<p><strong>在开发中</strong> <strong>pubspec.yaml</strong> <strong>主要用来配置插件依赖、配置静态资源</strong>。</p>
<p>pubspec.yaml 文件的主要用途包括：</p>
<p><strong>声明依赖项</strong>：在 pubspec.yaml 中，你可以指定项目依赖的其他 Flutter 包或第三方库。通</p>
<p>过在文件中添加相应的包名称和版本约束，Flutter 可以自动管理包的安装和版本控制。</p>
<p><strong>配置项目信息</strong>：你可以在 pubspec.yaml 中提供项目的名称、描述、作者、版本号等信息，这些信息将在 pub.dev（Flutter 的包管理平台）上展示，帮助其他开发者了解你的项目。</p>
<p><strong>依赖约束</strong>：通过指定包的版本范围，你可以控制项目对特定包的版本依赖，确保项目的稳定</p>
<p>性和兼容性。</p>
<p><strong>插件配置</strong>：如果你的项目使用了插件（Plugins），你可以在 pubspec.yaml 中配置相关的插</p>
<p>件信息，例如插件的名称和路径。</p>
<p><strong>资源管理</strong>：你可以在 pubspec.yaml 中指定项目所需的资源文件，例如图片、字体等，Flutter</p>
<p>将在构建过程中将这些资源包含在应用程序中。</p>
<p><strong>12<strong><strong>、</strong></strong>Flutter</strong> <strong>中的</strong> <strong>Widget<strong><strong>、</strong></strong>State</strong> <strong>和</strong> <strong>BuildContext</strong> <strong>的作用</strong></p>
<p><strong>和区别</strong></p>
<p><strong>Widget</strong>：Widget 是构成 Flutter 应用程序用户界面的基本元素。它可以是一个按钮、文本、图片等</p>
<p><strong>State</strong>：在 Flutter 中，State 用于管理有状态 Widget 的状态。当有状态 Widget 的状态发生变化时，Flutter</p>
<p>框架会调用其 build 方法来更新用户界面。<strong>State</strong> <strong>的生命周期方法包括：</strong></p>
<p>initState：在 State 对象创建时调用，用于初始化状态。</p>
<p>didChangeDependencies：在 State 对象的依赖关系发生变化时调用，例如数据源的更改。</p>
<p>build：在 Widget 的状态发生变化时调用，用于构建新的用户界面。</p>
<p>didUpdateWidget：在 Widget 更新时调用，例如父 Widget 的属性发生变化。</p>
<p>deactivate：在 State 对象失去关联的 Widget 时调用。</p>
<p>dispose：在 State 对象被销毁时调用，用于释放资源。</p>
<p><strong>BuildContext</strong>：BuildContext 是 Flutter 框架在构建 Widget 时提供的上下文信息。它包含当前构建过程中的相关</p>
<p>信息，例如 Widget 的父容器、主题、布局约束等</p>
<p>以下是 build 方法的基本结构和用法</p>
<p>Widget build(BuildContext context) {</p>
<p>&#x2F;&#x2F; 在这里构建和返回 Widget 树</p>
<p>}</p>
<p>有状态组件（Stateful Widgets）的 build 方法</p>
<p>class MyStatefulWidget extends StatefulWidget {</p>
<p>@override</p>
<p>_MyStatefulWidgetState createState() &#x3D;&gt; _MyStatefulWidgetState();</p>
<p>}</p>
<p>class _MyStatefulWidgetState extends State<MyStatefulWidget> {@override </p>
<p>Widget build(BuildContext context) {</p>
<p>&#x2F;&#x2F; 在这里构建和返回 Widget 树</p>
<p>}</p>
<p>}</p>
<p>无状态组件（Stateless Widgets）的 build 方法</p>
<p>对于无状态组件，build 方法通常位于组件类的直接内部。无状态组件不包含可变状态，因此 build 方法可以直接在组</p>
<p>件类内部定义。</p>
<p>class MyStatelessWidget extends StatelessWidget {</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>&#x2F;&#x2F; 在这里构建和返回 Widget 树</p>
<p>}</p>
<p>}</p>
<p><strong>build</strong> <strong>方法接受一个</strong> <strong>BuildContext</strong> <strong>对象作为参数。****BuildContext</strong> <strong>是一个用于获取与构建上下文相关信息的对象，例如</strong></p>
<p><strong>主题、媒体查询信息等。它是构建过程中的上下文环境。</strong> </p>
<p><strong>位置信息****：</strong>获取屏幕的方向</p>
<p>class MyStatefulWidget extends StatefulWidget {</p>
<p>@override</p>
<p>_MyStatefulWidgetState createState() &#x3D;&gt; _MyStatefulWidgetState();</p>
<p>}</p>
<p>class _MyStatefulWidgetState extends State<MyStatefulWidget> {</p>
<p>@override</p>
<p>Widget build(BuildContext context) {</p>
<p>&#x2F;&#x2F; 在这里构建和返回 Widget 树</p>
<p>print(MediaQuery.of(context).orientation);</p>
<p>… </p>
<p>}</p>
<p>}<strong>主题信息****：</strong>BuildContext 允许你访问应用程序的主题数据。通过 Theme.of(context)，可以获取当前上下文中的主题，</p>
<p>从而根据主题数据自定义 Widget 的外观。</p>
<p>class MyStatelessWidget extends StatelessWidget {</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>final ThemeData theme &#x3D; Theme.of(context);</p>
<p>… </p>
<p>}</p>
<p>}</p>
<p>class MyStatelessWidget extends StatelessWidget {</p>
<p>@override </p>
<p>Widget build(BuildContext context) { </p>
<p>return Text( </p>
<p>“我是一个标题”, </p>
<p>style: Theme.of(context).textTheme.labelLarge, </p>
<p>)</p>
<p>}</p>
<p>}</p>
<p><strong>媒体查询信息</strong>：BuildContext 还允许执行媒体查询，以获取有关设备屏幕的信息，如屏幕宽度、高度和方向。这对</p>
<p>于创建响应式布局非常有用。</p>
<p>class MyStatefulWidget extends StatefulWidget {</p>
<p>@override</p>
<p>_MyStatefulWidgetState createState() &#x3D;&gt; _MyStatefulWidgetState();</p>
<p>}</p>
<p>class _MyStatefulWidgetState extends State<MyStatefulWidget> {</p>
<p>@override</p>
<p>Widget build(BuildContext context) {</p>
<p>&#x2F;&#x2F; 在这里构建和返回 Widget 树</p>
<p>final MediaQueryData mediaQuery &#x3D; MediaQuery.of(context);</p>
<p>final double screenWidth &#x3D; mediaQuery.size.width;</p>
<p>final double screenHeight &#x3D; mediaQuery.size.height;</p>
<p>final Orientation orientation &#x3D; mediaQuery.orientation;</p>
<p>…. </p>
<p>}</p>
<p>}<strong>13****、什么是</strong> <strong>BuildContext****？</strong></p>
<p><strong>同上</strong></p>
<p>build 方法接受一个 BuildContext 对象作为参数。BuildContext 是一个用于获取与构建上下文</p>
<p>相关信息的对象，例如<strong>主题</strong>、<strong>媒体查询信息</strong>等。它是构建过程中的上下文环境。</p>
<p>class MyStatelessWidget extends StatelessWidget {</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>final ThemeData theme &#x3D; Theme.of(context);</p>
<p>… </p>
<p>final MediaQueryData mediaQuery &#x3D; MediaQuery.of(context);</p>
<p>}</p>
<p>}</p>
<p><strong>14<strong><strong>、</strong></strong>Flutter</strong> <strong>的渲染流程</strong></p>
<p>Flutter 的渲染流程是将 Widget 转换为显示在屏幕上的像素的过程。它涉及多个阶段，包括</p>
<p><strong>构建、布局、绘制和合成</strong></p>
<p><strong>构建（<strong><strong>Build</strong></strong>）</strong>：在这个阶段，Flutter 框架会根据 Widget 树中的变化调用每个 Widget 的 build</p>
<p>方法。Widget 的 build 方法返回一个新的 Widget，表示当前 Widget 的最新状态。这个阶段</p>
<p>主要是为了确定哪些 Widget 需要更新。</p>
<p><strong>布局（<strong><strong>Layout</strong></strong>）</strong>：在构建阶段之后，Flutter 框架会执行布局过程，为每个需要更新的 Widget</p>
<p>确定其在屏幕上的位置和大小。这个阶段会调用每个 Widget 的 layout 方法，根据其约束条</p>
<p>件（如最大宽度、最小高度等）计算出最佳的位置和大小。</p>
<p><strong>绘制（<strong><strong>Paint</strong></strong>）</strong>：在布局阶段完成后，Flutter 框架会执行绘制过程，根据每个 Widget 的布局</p>
<p>信息将其绘制到屏幕上。这个阶段会调用每个 Widget 的 paint 方法，将 Widget 的内容绘制</p>
<p>到一个离屏的 Canvas 上。</p>
<p><strong>合成（<strong><strong>Compositing</strong></strong>）：</strong>在绘制阶段完成后，Flutter 框架会执行合成过程，将所有已绘制的</p>
<p>Canvas 组合成最终的显示图像。这个阶段会调用每个 Widget 的 compositing 方法，将它们的</p>
<p>绘制结果合并到一起。</p>
<p><strong>显示（<strong><strong>Display</strong></strong>）</strong>：在合成阶段完成后，Flutter 框架会将最终的显示图像发送给硬件，将其显</p>
<p>示在屏幕上。<strong>在</strong> <strong>Flutter</strong> <strong>渲染流程中，有一些关键的概念需要了解：</strong></p>
<p><strong>Widget</strong>：Widget 是构成 Flutter 应用程序用户界面的基本元素。</p>
<p><strong>Element</strong>：</p>
<p>E</p>
<p>lement 表示一个 Widget 在 Widget 树中的位置。它是一个 Dart 类，用于描述 Widget</p>
<p>在渲染流程中的状态和行为。</p>
<p><strong>BuildContext</strong>：BuildContext 是 Flutter 框架在构建 Widget 时提供的上下文信息。它包含当前</p>
<p>构建过程中的相关信息，例如 Widget 的父容器、主题、布局约束等。</p>
<p><strong>15****、如何优化</strong> <strong>Flutter</strong> <strong>渲染流程以提高性能</strong></p>
<p>1、减少不必要的 Widget，减少 Widget 的嵌套</p>
<p>2、能用无状态自定义组件不用有状态的，无状态 Widget 在创建后不会发生变化。</p>
<p>3、优化布局，避免使用复杂的布局，因为布局计算在渲染流程中占用了大量时间。尽可能</p>
<p>使用简单的布局，例如 Row、Column 和 Stack。</p>
<p>4、静态组件前面加上 Const ，这样重新渲染的时候就不会渲染这个组件了，优化渲染时间</p>
<p>5、使用缓存，可以使用 CachedNetworkImage 来缓存网络图片，或者使用 MemoryImage 来</p>
<p>缓存本地图片。</p>
<p>6、Android 中可以启用硬件加速：启用硬件加速可以提高渲染性能。可以在应用程序的</p>
<p>AndroidManifest.xml 文件中添加以下代码来启用硬件加速：</p>
<p>&lt;application</p>
<p>android:hardwareAccelerated&#x3D;”true”</p>
<p>… </p>
</application>

<p>7、用局部更新代替全局 build 如：流技术 或者 getx 等</p>
<p>8、使用性能分析工具：使用性能分析工具（如 Flutter DevTools）可以帮助你找到渲染流程</p>
<p>中的瓶颈。通过分析内存占用、CPU 使用率和 GPU 使用率等指标，可以找到需要优化的地</p>
<p>方。</p>
<p><strong>16****、如何优化</strong> <strong>Flutter</strong> <strong>的运行速度</strong></p>
<p>同上<strong>17****、如何在</strong> <strong>Flutter</strong> <strong>中实现网络请求</strong></p>
<p>在 Flutter 中实现网络请求有很多模块，可以使用 http 模块，也可以使用 dio 模块</p>
<p>具体的用法在 <a target="_blank" rel="noopener" href="https://pub.dev/%E4%B8%8A%E9%9D%A2%E6%9C%89%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BB%A5%E5%89%8D%E7%9A%84%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E7%9A%84%E6%98%AF">https://pub.dev/上面有，我们以前的的项目中用的是</a> Dio 库，它支持 get post</p>
<p>put delete 还支持文件的上传下载</p>
<p>import ‘package:dio&#x2F;dio.dart’;</p>
<p>final dio &#x3D; Dio();</p>
<p>void getHttp() async {</p>
<p>final response &#x3D; await dio.get(‘<a target="_blank" rel="noopener" href="https://dart.dev/">https://dart.dev</a>‘);</p>
<p>print(response);</p>
<p>}</p>
<p>import ‘package:dio&#x2F;dio.dart’;</p>
<p>class HttpsClient {</p>
<p>static String domain &#x3D; “<a target="_blank" rel="noopener" href="https://xiaomi.itying.com/">https://xiaomi.itying.com/</a>“;</p>
<p>static Dio dio &#x3D; Dio();</p>
<p>HttpsClient() {</p>
<p>dio.options.baseUrl &#x3D; domain;</p>
<p>dio.options.connectTimeout &#x3D; const Duration(milliseconds: 5000); &#x2F;&#x2F;5s</p>
<p>dio.options.receiveTimeout &#x3D; const Duration(milliseconds: 5000);</p>
<p>}</p>
<p>Future get(apiUrl) async {</p>
<p>try {</p>
<p>var response &#x3D; await dio.get(apiUrl);</p>
<p>return response;</p>
<p>} catch (e) {</p>
<p>print(“请求超时”);</p>
<p>return null;</p>
<p>}</p>
<p>}</p>
<p>Future post(String apiUrl, {Map? data}) async {</p>
<p>try {</p>
<p>var response &#x3D; await dio.post(apiUrl, data: data);</p>
<p>return response;</p>
<p>} catch (e) {</p>
<p>print(“请求超时”);</p>
<p>return null;</p>
<p>}</p>
<p>}</p>
<p>}<strong>18<strong><strong>、</strong></strong>Flutter</strong> <strong>中的状态管理是什么，****Flutter</strong> <strong>中如何实现状态</strong></p>
<p><strong>管理</strong></p>
<p>通俗的讲：当我们想在多个页面（组件&#x2F;Widget）之间共享状态（数据），或者一个页面（组</p>
<p>件&#x2F;Widget）中的多个子组件之间共享状态（数据），这个时候我们就可以用 Flutter 中的状</p>
<p>态管理来管理统一的状态（数据），实现不同组件直接的传值和数据共享。</p>
<p>现在 Flutter 的状态管理方案很多，provider、getx、redux、bloc 等</p>
<p><strong>19****、什么是</strong> <strong>Bloc****？</strong></p>
<p>Bloc 是一种用于管理状态和业务逻辑的 Flutter 架构模式，通过 Stream 和 Sink 实现。</p>
<p><strong>20****、 什么是</strong> <strong>Provider****？</strong></p>
<p>Provider 是 Flutter 中的一个状态管理库，用于应用不同页面的状态或者数据共享</p>
<p><strong>21<strong><strong>、</strong></strong>Flutter</strong> <strong>中如何实现数据持久化</strong></p>
<p>Flutter 中实现数据持久化可以使用 <strong>shared_preferences</strong> 模块或者 sqlite 模块或者 <strong>Realm</strong> <strong>本地</strong></p>
<p><strong>数据库</strong>实现。</p>
<p><strong>shared_preferences</strong> <strong>在</strong> <strong>Flutter</strong> <strong>仿小米实战中有讲</strong></p>
<p><strong>Realm</strong> <strong>本地数据库在</strong> <strong>flutter</strong> <strong>桌面软件开发中有讲</strong></p>
<p>以前开发项目的时候主要用过 shared_preferences，会 sqlite 可以说用过，不会 sqlite 也可以</p>
<p>说没有用过，贵公司要用这个话我可以看看官方文档，这些都不难</p>
<p>下面是封装的 shared_preferences</p>
<p>import ‘dart:convert’;</p>
<p>import ‘package:shared_preferences&#x2F;shared_preferences.dart’;</p>
<p>class Storage {</p>
<p>static setData(String key, dynamic value) async {</p>
<p>var prefs &#x3D; await SharedPreferences.getInstance();</p>
<p>prefs.setString(key, json.encode(value));</p>
<p>}static getData(String key) async {</p>
<p>try {</p>
<p>var prefs &#x3D; await SharedPreferences.getInstance();</p>
<p>String? tempData &#x3D; prefs.getString(key);</p>
<p>if (tempData !&#x3D; null) {</p>
<p>return json.decode(tempData);</p>
<p>} else {</p>
<p>return null;</p>
<p>}</p>
<p>} catch (e) {</p>
<p>return null;</p>
<p>}</p>
<p>}</p>
<p>static removeData(String key) async {</p>
<p>var prefs &#x3D; await SharedPreferences.getInstance();</p>
<p>prefs.remove(key);</p>
<p>}</p>
<p>static clear(String key) async {</p>
<p>var prefs &#x3D; await SharedPreferences.getInstance();</p>
<p>prefs.clear();</p>
<p>}</p>
<p>}</p>
<p><strong>22<strong><strong>、</strong></strong>Flutter</strong> <strong>中如何实现路由和导航</strong></p>
<p>可以使用官方的 Navigator 组件管理路由导航，我们自己封装过对应的方法，配置也很简单</p>
<p>的，也可以使用 Getx 自带的路由或者使用 go-router 实现</p>
<p><strong>Flutter</strong> <strong>自带路由参考</strong>**–<strong><strong>《</strong></strong>Flutter+Getx** <strong>仿小米商城项目（****22-24</strong> <strong>讲）》</strong></p>
<p><strong>Getx</strong> 自带的路由可以通过 Get_Cli 自动生成，也可以自己配置</p>
<p><strong>go-router</strong> 可以参考《Flutter 仿阿里网盘桌面软件开》或者参考官方文档<strong>23<strong><strong>、</strong></strong>Flutter</strong> <strong>中如何实现异步操作，请解释一下</strong> <strong>Future</strong> <strong>和</strong></p>
<p><strong>Stream</strong> <strong>的概念。</strong></p>
<p><strong>Flutter</strong> <strong>中通过</strong> Future 或者 Stream 实现实现异步</p>
<p>Future 在未来只会获取一个值。Stream 的字面意思是水流，Stream 不像 Future 那样只</p>
<p>会在未来获取一个值，它可以异步获取 0 个或者多个值。如果说 Future 是一个异步版本的</p>
<p>int 或者 String，Stream 则更像是异步版本的列表 </p>
<p><strong>一、****Flutter</strong> <strong>实现异步</strong></p>
<p>Future<int> performAsyncOperation() {</p>
<p>return Future.delayed(Duration(seconds: 2), () {</p>
<p>&#x2F;&#x2F; 异步操作的代码</p>
<p>return 42;</p>
<p>});</p>
<p>}</p>
<p>void main() async {</p>
<p>int result &#x3D; await performAsyncOperation();</p>
<p>&#x2F;&#x2F; 使用异步操作的结果</p>
<p>print(result);</p>
<p>}</p>
<p><strong>二、****Stream</strong> <strong>实现异步</strong></p>
<p>Stream<int> createStream() {</p>
<p>return Stream.periodic(Duration(seconds: 1), (i) &#x3D;&gt; i);</p>
<p>}</p>
<p>void main() {</p>
<p>createStream().listen((data) {</p>
<p>&#x2F;&#x2F; 处理数据流中的每个数据项</p>
<p>print(data);</p>
<p>});</p>
<p>}</p>
<p><strong>详情参考《第三十八讲》、《第三十九讲》、《第四十讲》<strong><strong>24</strong></strong>、如何实现</strong> <strong>Flutter</strong> <strong>的热重载？</strong></p>
<p>可以通过快捷键“R”实现</p>
<p>Flutter 常用的快捷键</p>
<p>r 键 ：点击后热加载，也就算是重新加载吧。</p>
<p>R 键：热重启项目。</p>
<p>p 键：显示网格，这个可以很好的掌握布局情况，工作中很有用。</p>
<p>o 键：切换 android 和 ios 的预览模式。</p>
<p>q 键：退出调试预览模式。</p>
<p><strong>25****、</strong> <strong>Flutter</strong> <strong>热加载和热重启什么区</strong></p>
<p><strong>热加载：</strong> 控制台按 小 r 可以实现热加载</p>
<p>热重载是指在不重新启动应用程序的情况下，更新正在运行的应用程序的状态，同时保留当前状态。热重</p>
<p>载主要是执行 build 方法，通过重新构建小部件树来更新应用程序的状态。因此，热重载速度较快，只需</p>
<p>要几百毫秒即可完成更新。 </p>
<p><strong>热重启：</strong> 控制台按 大 R 可以实现热加载 </p>
<p>（shift+r）</p>
<p>热重启则是重新启动整个应用程序，并从头开始重建小部件树。热重启适用于修改了资源文件或需要重新</p>
<p>构建状态的情况，因为它会重新启动整个应用程序，并重新构建小部件树，以反映新的状态。因此，热重</p>
<p>启速度相对较慢，需要秒单位</p>
<p>有时候热加载页面没有变化的时候，我们需要（shift+r）热重启一下</p>
<p><strong>26****、如何在</strong> <strong>Flutter</strong> <strong>中添加和使用第三方包</strong></p>
<p><strong>1****、</strong>pub.dev 上面找到对应的包按照文档操作 <a target="_blank" rel="noopener" href="https://pub.dev/">https://pub.dev/</a></p>
<p>2、vscode 开发的话由于配置了 flutter 插件，配置依赖保存后会自动下载依赖</p>
<p><strong>27<strong><strong>、</strong></strong>Flutter</strong> <strong>中如何清理项目缓存</strong></p>
<p>清理项目缓存可以使用 flutter clean 命令 （cd 到项目根目录执行）</p>
<p>flutter pub cache clean 是 Flutter 提供的一个命令，用于清除 Flutter 应用的本地缓存，主要用</p>
<p>于在开发过程中解决依赖包冲突或者其他本地缓存问题。 （命令行任意地方都可以执行）<strong>28<strong><strong>、</strong></strong>flutter clean</strong> <strong>和</strong> <strong>flutter pub cache clean</strong> <strong>区别</strong></p>
<p>flutter clean 清理项目缓存，比如真机调试没有问题，但是正式打包提示项目包有问题，这</p>
<p>个时候就可以运行一下 flutter clean </p>
<p>（cd 到项目根目录执行）</p>
<p>flutter pub cache clean 清除 Flutter 应用的本地缓存, 以前项目可以正常运行，安装完成插件</p>
<p>后没法正常运行了，这个时候可以清理本地缓存试试。（命令行任意地方都可以执行）</p>
<p><strong>29****、如何升级</strong> <strong>flutter sdk</strong></p>
<p>1、使用 flutter upgrade 升级（不推荐 肯能会失败 或者把本地环境整坏）</p>
<p>2、手动升级</p>
<p>(1) 重新下载最新的 flutter SDK</p>
<p>(2) 建议到一个目录 （不要有空格）</p>
<p>(3) 把 Flutter Sdk Bin 目录重新配置到环境变量</p>
<p>(4) flutter doctor 检测环境</p>
<p><strong>30****、升级</strong> <strong>flutter sdk</strong> <strong>后发现以前的老项目没法正常运行了</strong></p>
<p><strong>如何解决</strong></p>
<p>1、新建项目–确保可以运行 （包名称、目录名称和老项目需要配置成一样的）</p>
<p>2、把老项目的 lib 目录复制到新建的项目里面</p>
<p>3、把老项目的 assets 静态资源目录复制到新项目里面</p>
<p>4、把老项目 pubspec.yaml 中的依赖重新配置到新项目中</p>
<p>5、运行</p>
<p><strong>31****、</strong> <strong>Flutter</strong> *<em>有状态组件中“</em>***setState()**<strong>”方法的用途是什</strong></p>
<p><strong>么</strong></p>
<p>在 Flutter 中，setState()方法用于更新有状态小部件的状态。当状态改变时，setState()方法会再次</p>
<p>调用 build()方法，并更新用户界面以反映新状态。<strong>32****、</strong> <strong>Dart</strong> <strong>语言特性和</strong> <strong>Flutter</strong> <strong>中的应用</strong></p>
<p>Dart 是谷歌开发的一种强类型语言。和 JavaScript 、java 这些语言都有点相似</p>
<p>Flutter 就是基于 Dart 语言开发的，Flutter 中的 Widget 其实就是 Dart 类</p>
<p><strong>33****、</strong> <strong>Dart Flutter</strong> <strong>中如何实现多继承</strong></p>
<p>在 Dart Flutter 中，使用 extends 关键字表示继承关系，使用 with 关键字可以实现多继承</p>
<p>class People {</p>
<p>String name;</p>
<p>int age; </p>
<p>void basicInformation() {</p>
<p>print(‘人类信息’);</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F; 学生类 使用 extends 关键字表示 Student 类继承自 People 类</p>
<p>class Student extends People {</p>
<p>String studentId;</p>
<p>String studentIdentity;</p>
<p>@override</p>
<p>void basicInformation() {</p>
<p>print(‘学生信息’);</p>
<p>}</p>
<p>}</p>
<p>class Worker {</p>
<p>String workerId;</p>
<p>String workerName; </p>
<p>void workerInfo() {</p>
<p>print(‘打工人信息’);</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F; myIdentify 类使用 with 继承了 Student 和 Worker 类</p>
<p>class myIdentify extends Student with Worker { </p>
<p>void infor() {</p>
<p>print(‘我的信息’);</p>
<p>}</p>
<p>}<strong>34****、</strong> <strong>Dart Flutter</strong> <strong>中的面向对象是如何理解的</strong></p>
<p>Dart 是一门面向对象的语言，具有面向对象的三大特性：封装、继承、多态。</p>
<p><strong>封装</strong>是对象和类概念的主要特性。它把客观事物封装成抽象的类，并且把自己的部分属性和方法提供给其</p>
<p>他对象调用，而一部分属性和方法则隐藏。</p>
<p><strong>继承</strong>是复用的一种手段，子类继承父类，会继承父类的所有公开属性和公开方法（包括计算属性），私有</p>
<p>的属性和方法则不会被继承。子类可以覆写父类的公开方法。</p>
<p><strong>多态</strong>性是指允许将子类类型的指针赋值给父类类型的指针，同一个函数调用会有不同的执行效果。</p>
<p>封装、继承都好理解，这里主要提供多态的例子</p>
<p><strong>多态是同一种行为具有不同表现形式或形态。以下是一个</strong> <strong>Dart</strong> <strong>多态代码示例：</strong></p>
<p>void main() {</p>
<p>&#x2F;&#x2F; 创建两个动物对象</p>
<p>Animal dog &#x3D; new Dog();</p>
<p>Animal sheep &#x3D; new Sheep();</p>
<p>&#x2F;&#x2F; 调用动物的 eat 方法</p>
<p>dog.eat(); </p>
<p>sheep.eat();</p>
<p>}</p>
<p>class Animal { </p>
<p>void eat() {</p>
<p>print(‘Animal class eat.’);</p>
<p>}</p>
<p>}</p>
<p>class Dog extends Animal {</p>
<p>@override</p>
<p>void eat() {</p>
<p>print(‘Dog eat meat.’);</p>
<p>}</p>
<p>}</p>
<p>class Sheep extends Animal {</p>
<p>@override</p>
<p>void eat() {</p>
<p>print(‘Sheep eat grass.’);</p>
<p>}</p>
<p>}<strong>35<strong><strong>、 面向对象编程（</strong></strong>OOP****）的四个原则是什么？</strong></p>
<p>面向对象编程（OOP）的四个基本原则是<strong>抽象</strong>（Abstraction）、<strong>封装</strong>（Encapsulation）、<strong>继</strong></p>
<p><strong>承</strong>（Inheritance）和<strong>多态</strong>（Polymorphism）。这些原则被称为「抽象、封装、继承、多态」</p>
<p>（Abstraction, Encapsulation, Inheritance, Polymorphism）或「AEIP 原则」。</p>
<p>这些原则是面向对象编程的基础，它们用于指导设计和组织代码的方式，以实现代码的可维</p>
<p>护性、可扩展性和重用性。</p>
<p><strong>抽象</strong>（Abstraction）：抽象是将复杂的现实世界问题简化为适合程序处理的模型。通过抽象，</p>
<p>我们可以关注对象的关键特征和行为，忽略其细节。抽象可以通过类、接口和抽象类来实现。</p>
<p><strong>封装</strong>（Encapsulation）：封装是将数据和操作数据的方法封装在一个单元（类）中，以实现</p>
<p>信息隐藏和访问控制。封装通过将相关的数据和方法组织在一起，形成一个独立的模块，并</p>
<p>限制外部访问来保护数据的完整性。</p>
<p><strong>继承</strong>（Inheritance）：继承是通过创建新的类（子类）来继承现有类（父类）的属性和方法。</p>
<p>继承可以实现代码的重用和层次化的组织。子类可以继承父类的属性和方法，并可以添加新</p>
<p>的属性和方法，或者重写父类的方法。</p>
<p><strong>多态</strong>（Polymorphism）：多态是指同一个方法可以在不同的对象上具有不同的行为。多态允</p>
<p>许使用基类或接口类型的引用来引用具体的子类对象，从而实现动态绑定和灵活的代码扩展。</p>
<p><strong>36****、什么是</strong> <strong>Future****？</strong></p>
<p>Future 是一种异步操作，可以通过 async 和 await 关键字来使用</p>
<p>Future<int> performAsyncOperation() { </p>
<p>return Future.delayed(Duration(seconds: 2), () {</p>
<p>&#x2F;&#x2F; 异步操作的代码</p>
<p>return 42;</p>
<p>});</p>
<p>}</p>
<p>void main() async {</p>
<p>int result &#x3D; await performAsyncOperation();</p>
<p>&#x2F;&#x2F; 使用异步操作的结果</p>
<p>print(result);</p>
<p>}<strong>37****、什么是</strong> <strong>Stream****？</strong></p>
<p>Flutter 中 Stream 也是实现异步编程的一种方式</p>
<p>Stream 的字面意思是水流，Stream 不像 Future 那样只会在未来获取一个值，它可以异步获取 0 个或者多个值。如果</p>
<p>说 Future 是一个异步版本的 int 或者 String，Stream 则更像是异步版本的列表。</p>
<p>Stream 一般结合 StreamBuilder 和 StreamController 使用</p>
<p>Stream<int> createStream() { </p>
<p>return Stream.periodic(Duration(seconds: 1), (i) &#x3D;&gt; i);</p>
<p>}</p>
<p>void main() { </p>
<p>createStream().listen((data) {</p>
<p>&#x2F;&#x2F; 处理数据流中的每个数据项</p>
<p>print(data);</p>
<p>});</p>
<p>}</p>
<p>import ‘package:flutter&#x2F;material.dart’;</p>
<p>import ‘dart:async’; &#x2F;&#x2F; 需要导入异步包</p>
<p>void main() { </p>
<p>runApp(MyApp());</p>
<p>}</p>
<p>class MyApp extends StatelessWidget {</p>
<p>@override </p>
<p>Widget build(BuildContext context) { </p>
<p>return MaterialApp(</p>
<p>title: ‘Flutter Demo’, </p>
<p>home: DemoPage(), </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p>class DemoPage extends StatefulWidget {</p>
<p>@override</p>
<p>State<DemoPage> createState() &#x3D;&gt; _DemoPageState();</p>
<p>}class _DemoPageState extends State<DemoPage> {</p>
<p>&#x2F;&#x2F; 定义一个类型为 int 的 Stream</p>
<p>final _controller &#x3D; StreamController<int>();</p>
<p>@override</p>
<p>void dispose() { </p>
<p>super.dispose(); </p>
<p>_controller.close();</p>
<p>}</p>
<p>@override </p>
<p>Widget build(BuildContext context) { </p>
<p>return Scaffold( </p>
<p>appBar: AppBar(</p>
<p>title: const Text(“Stream Demo”), </p>
<p>),</p>
<p>body: Wrap( </p>
<p>spacing: 20, </p>
<p>children: [</p>
<p>ElevatedButton(</p>
<p>&#x2F;&#x2F; 按钮点击后 Stream 会释放出数字 1</p>
<p>child: const Text(“Emit 1”), </p>
<p>onPressed: () &#x3D;&gt; _controller.add(1), </p>
<p>),</p>
<p>ElevatedButton(</p>
<p>&#x2F;&#x2F; 按钮点击后 Stream 会释放出数字 2</p>
<p>child: const Text(“Emit 2”), </p>
<p>onPressed: () &#x3D;&gt; _controller.add(2), </p>
<p>),</p>
<p>ElevatedButton(</p>
<p>&#x2F;&#x2F; 按钮点击后 Stream 会释放出一个错误</p>
<p>child: const Text(“Emit Error”), </p>
<p>onPressed: () &#x3D;&gt; _controller.addError(“oops”), </p>
<p>),</p>
<p>ElevatedButton(</p>
<p>&#x2F;&#x2F; 按钮点击后 Stream 会关闭</p>
<p>child: const Text(“Close”), </p>
<p>onPressed: () &#x3D;&gt; _controller.close(), </p>
<p>),</p>
<p>StreamBuilder( </p>
<p>stream: _controller.stream , </p>
<p>builder: (context, snapshot) {</p>
<p>print(“正在重新绘制 StreamBuilder 组件…”);</p>
<p>if (snapshot.connectionState &#x3D;&#x3D; ConnectionState.done) {return const Text(“数据流已关闭”);</p>
<p>}</p>
<p>if (snapshot.hasError) return Text(“${snapshot.error}”);</p>
<p>if (snapshot.hasData) return Text(“${snapshot.data}”); </p>
<p>return const Center( </p>
<p>child: CircularProgressIndicator(), </p>
<p>);</p>
<p>}, </p>
<p>)</p>
<p>], </p>
<p>), </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p><strong>38<strong><strong>、</strong></strong>Flutter</strong> <strong>动画有哪些</strong></p>
<p><strong>FLutter</strong> <strong>中的动画主要分为</strong>：隐式动画、显式动画、自定义隐式动画、自定义显式动画、和 Hero</p>
<p>动画 。</p>
<p><strong>隐式动画</strong><strong>:</strong> AnimatedContainer、AnimatedPadding、AnimatedPositioned、AnimatedOpacity <strong>等</strong></p>
<p><strong>常见的显式动画有：</strong> RotationTransition、FadeTransition、ScaleTransition、SlideTransition、</p>
<p>AnimatedIcon 。 在 显 示 动 画 中 开 发 者 需 要 创 建 一 个 AnimationController ， 通 过</p>
<p>AnimationController 控制动画的开始、暂停、重置、跳转、倒播等。</p>
<p>使用 TweenAnimationBuilder 自定义隐式动画</p>
<p>使用 AnimatedBuilder 自定义显式动画</p>
<p><strong>详情参考《****31-35</strong> <strong>讲 动画章节》<strong><strong>39</strong></strong>、****Flutter</strong> <strong>中 实 现 自 定 义 动 画 ， 请 解 释 一 下</strong></p>
<p><strong>AnimatedBuilder</strong> <strong>和</strong> <strong>Tween</strong> <strong>的概念</strong></p>
<p>使用 TweenAnimationBuilder 自定义隐式动画,Tween 可以定义动画区间</p>
<p>class MyHomePage extends StatefulWidget { </p>
<p>const MyHomePage({super.key});</p>
<p>@override</p>
<p>State<MyHomePage> createState() &#x3D;&gt; _MyHomePageState();</p>
<p>}</p>
<p>class _MyHomePageState extends State<MyHomePage> </p>
<p>with SingleTickerProviderStateMixin {</p>
<p>late AnimationController _controller;</p>
<p>@override</p>
<p>void initState() { </p>
<p>super.initState(); </p>
<p>_controller &#x3D;AnimationController(vsync: this, duration: const Duration(seconds: 1))</p>
<p>..repeat(reverse: true);</p>
<p>}</p>
<p>@override </p>
<p>Widget build(BuildContext context) { </p>
<p>return Scaffold( </p>
<p>appBar: AppBar(</p>
<p>title: const Text(‘Title’), </p>
<p>),</p>
<p>body: Center( </p>
<p>child: AnimatedBuilder( </p>
<p>animation: _controller, </p>
<p>builder: (BuildContext context, Widget? child) { </p>
<p>return Opacity( </p>
<p>opacity: Tween(begin: 0.5,end: 1.0).animate(_controller).value, &#x2F;&#x2F;从 0.5 到 1 的变化</p>
<p>child: Container( </p>
<p>width: 200, </p>
<p>height: 200, </p>
<p>color: Colors.red, </p>
<p>child: const Text(“我是一个 text 组件”), </p>
<p>), </p>
<p>);</p>
<p>}, </p>
<p>), </p>
<p>), </p>
<p>);}</p>
<p>}</p>
<p><strong>40<strong><strong>、</strong></strong>Flutter</strong> <strong>和后端交互的时候如何保证数据的安全</strong></p>
<p>1、使用安全的 Https 网络协议：确保使用 HTTPS 协议进行数据传输，以加密客户端与服务器之间的通信，</p>
<p>防止数据在传输过程中被窃听或篡改</p>
<p>2、签名验证：登录后才能访问的内容需要签名认证，我们项目中都是自己写的签名验证算法，具有数据校</p>
<p>验 和数据完整性验证</p>
<p>3、后端开发日志和监控系统：建立有效的日志记录和监控系统，以便及时检测和响应任何异常或可疑的活</p>
<p>动。</p>
<p>4、安全的 API 设计：设计后端 API 时，遵循安全最佳实践</p>
<p><strong>41****、如何在</strong> <strong>Flutter</strong> <strong>中与后端进行数据交互和</strong> <strong>API</strong> <strong>调用</strong></p>
<p>1、选择请求数据的方式，我们项目中目前都是使用的 DIO 库请求的数据。</p>
<p>2、与后端一起确定请求数据的方式，确定 API 的结构和功能。</p>
<p>3、定义请求数据的数据模型，解析服务器返回的数据 （这个是重点）</p>
<p>4、请求数据，解析数据、处理数据（包含错误处理）</p>
<p>5、绑定数据渲染数据</p>
<p>42、<strong>flutter</strong> <strong>请求远程</strong> <strong>API</strong> <strong>接口的时候为什么要定义数据模</strong></p>
<p><strong>型</strong></p>
<p>小项目中使用 dart:convert 手动序列化 JSON 非常好，也非常快速。但是随着项目的增大，dart:convert 手动</p>
<p>序列化 JSON 的话失去了大部分静态类型语言特性：类型安全、自动补全和最重要的编译时异常。这样以来</p>
<p>来，我们的代码可能会变得非常容易出错。</p>
<p>当我们访问 name 或 email 字段时，我们输入的很快，导致字段名打错了。但由于这个 JSON 在 map 结构中，</p>
<p>所以编译器不知道这个错误的字段名。</p>
<p>为了解决上面的问题在大型项目中使用的更多的是在模型类中序列化 JSON。 </p>
<p><strong>下面是定义数据模型的好处</strong></p>
<p><strong>结构清晰</strong>：数据模型提供了一种清晰的方式来表示和组织 API 接口返回的数据。通过定义数据模型，开发</p>
<p>者可以更好地理解数据的结构和关系，使代码更具可读性和可维护性。<strong>数据映射</strong>：将 API 返回的原始数据映射到定义的数据模型中，可以方便地进行数据的转换和处理。这样可</p>
<p>以减少代码中的复杂数据解析逻辑，使代码更加简洁和易于理解。</p>
<p><strong>一致性和准确性</strong>：使用数据模型可以确保数据在不同部分的代码中具有一致的结构和语义。这有助于避免</p>
<p>数据处理中的错误，并提高代码的稳定性。</p>
<p><strong>方便数据操作</strong>：数据模型通常包含数据的属性和方法，使得对数据的操作更加方便和直观。可以通过数据</p>
<p>模型提供的方法来访问和修改数据，增强代码的逻辑性和可复用性。</p>
<p><strong>与界面绑定</strong>：在 Flutter 中，数据模型常常与界面的渲染和更新紧密结合。通过将数据模型与界面元素进行</p>
<p>绑定，可以实现数据的自动同步和界面的实时更新，提高用户体验。</p>
<p><strong>提高代码的可扩展性</strong>：当 API 接口的结构或数据格式发生变化时，只需要修改数据模型的定义，而不需要</p>
<p>在多处代码中进行修改。这样可以减少代码修改的工作量，并提高代码的可扩展性。</p>
<p><strong>数据验证和错误处理：</strong>在数据模型中可以添加数据验证逻辑，确保接收到的数据符合预期的格式和约束。</p>
<p>这有助于提前发现和处理数据异常，提高应用的健壮性。</p>
<p><strong>43<strong><strong>、</strong></strong>Flutter</strong> <strong>生命周期函数有哪些，什么作用</strong></p>
<p>组件在初始化 → 创建 → 更新 → 卸载的时候自动执行的方法被称为生命周期函数，用的比较多的就是</p>
<p>initState 和 dispose </p>
<p>Flutter 中的生命周期函数有</p>
<p><strong>方法名</strong> </p>
<p><strong>所处时期</strong> </p>
<p><strong>描述</strong> </p>
<p><strong>调用次数</strong></p>
<p>initState </p>
<p>初始化期生命周期函数 </p>
<p>初始化 State，实现与渲染相关的初始化工作 </p>
<p>1</p>
<p>didChangeDependencies </p>
<p>更新期生命周期函数 </p>
<p>处理 State 对象依赖关系变化 </p>
<p>&gt;&#x3D;1</p>
<p>build </p>
<p>更新期生命周期函数 </p>
<p>构建视图 </p>
<p>&gt;&#x3D;1</p>
<p>didUpdateWidget </p>
<p>更新期生命周期函数 </p>
<p>Widget 的配置变化函数 </p>
<p>&gt;&#x3D;1</p>
<p>deactivate </p>
<p>销毁期生命周期函数 </p>
<p>组件被移除 </p>
<p>&gt;&#x3D;1</p>
<p>dispose </p>
<p>销毁期生命周期函数 </p>
<p>组件被销毁时调用 </p>
<p>1<strong>44****、如何在</strong> <strong>Flutter</strong> <strong>中实现多语言支持</strong></p>
<p>Flutter 中实现多语言支持可以使用 flutter init 模块</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ifmylove2011/article/details/125797598">https://blog.csdn.net/ifmylove2011/article/details/125797598</a></p>
<p><strong>45<strong><strong>、</strong></strong>如何在</strong> <strong>Flutter</strong> <strong>中实现视频播放？</strong></p>
<p>Flutter 中实现视频播放可以使用 video_player 或者 chewie 模块，也可以找一些其他模块实</p>
<p>现</p>
<p><strong>46****、如何在</strong> <strong>Flutter</strong> <strong>中实现地理定位和地图功能？</strong></p>
<p>可以使用高德定位 高德地图实现</p>
<p>1、申请成为高德地图开发者</p>
<p>2、创建应用配置获取 Key</p>
<p>3、安装依赖配置 amap_flutter_location</p>
<p>4、为了方便调试需要配置签名，配置签名文件 </p>
<p>找到 android &#x2F;app&#x2F;build.gradle 配置签名文</p>
<p>件</p>
<p>5、需要配置权限，修改你的 android&#x2F;app&#x2F;src&#x2F;main&#x2F;AndroidManifest.xml</p>
<p>6、注意还要申请权限</p>
<p>7、参考文档实现</p>
<p><strong>详情参考教程</strong></p>
<p>《53 【Flutter Plugins】Flutter Android 中集成高德定位 获取地理位置 加载高德地图》</p>
<p>《54【Flutter Plugins】Flutter Ios 中集成高德定位 获取地理位置》<strong>47****、如何在</strong> <strong>Flutter</strong> <strong>中实现支付功能？请解释一下支付宝和</strong></p>
<p><strong>微信支付的集成方法。</strong></p>
<p><strong>支付宝支付：</strong></p>
<p>支付宝支付比较复杂的就是服务端这块，客户端比较简单，获取服务器接口生成预支付信息，</p>
<p>调用插件传入预支付信息就可以实现支付了</p>
<p>1、在支付宝开放平台创建应用 生成签名 提交审核</p>
<p>2、服务器端调用支付宝 sdk 生成订单信息</p>
<p>3、 Flutter 中集成 <strong>Tobias</strong>，调用服务器端接口生成订单签名信息，调用支付插件完成支付</p>
<p>4、服务器端异步回调更新订单信息</p>
<p>5、Ios 中还需要配置 Schema</p>
<p><strong>微信支付：</strong></p>
<p>微信支付比较复杂的也是服务端这块，客户端比较简单，获取服务器接口生成预支付信息，</p>
<p>调用插件传入预支付信息就可以实现支付了，需要注意的是 Android 微信支付的时候需要需</p>
<p>要配置 signingConfigs 签名信息，不配置的话需要正式打包才能调试。Ios 中实现微信支付需</p>
<p>要配置 universalLink</p>
<p>1、注册开放平台、申请开发者、创建应用、 申请微信支付 、生成商户平台账户</p>
<p>2、获取 Android 应用签名、设置 ios 包名然后配置到微信开放平台</p>
<p>3、调用后台 api 接口生成签名字段</p>
<p>4、flutter 中集成支付插件 fluwx ，调用支付插件 fluwx 传入签名字段完成支付</p>
<p>5、Android 中需要配置 signingConfigs，方便调试</p>
<p>6、ios 中还需要配置 Schema 等</p>
<p>详情参考：</p>
<p>《57【 支付宝支付】支付宝支付流程以及 Flutter 在 android Ios 中实现支付宝支付（23 分</p>
<p>18 秒）》</p>
<p>《60【微信支付】微信 app 支付流程 、Flutter 在 Android 中实现微信支付，在 Android 中配</p>
<p>置 signingConfigs》</p>
<p><strong>48****、如何在</strong> <strong>Flutter</strong> <strong>中实现微信登录功能</strong></p>
<p>同微信支付，用的插件也是一样的<strong>49****、如何在</strong> <strong>Flutter</strong> <strong>中实现推送功能</strong></p>
<p>可以使用极光推送来实现</p>
<p><strong>Android</strong> <strong>集成极光推送</strong></p>
<p>1、官方注册账户 创建应用</p>
<p>2、在极光推送官网注册账户创建应用（看教程演示）</p>
<p>3、参考极光官方提供的 jpush-flutter sdk 集成极光推送</p>
<p><strong>Ios</strong> <strong>集成极光推送</strong></p>
<p>1、创建 flutter 项目 配置应用 Bundle ID（应用包名）</p>
<p>2、在极光推送官网注册账户、创建应用、配置证书</p>
<p>3、配置证书参考 <a target="_blank" rel="noopener" href="https://docs.jiguang.cn/jpush/client/iOS/ios_cer_guide/">https://docs.jiguang.cn/jpush/client/iOS/ios_cer_guide/</a></p>
<p>4、参考极光官方提供的 jpush-flutter sdk 集成极光推送</p>
<p><a target="_blank" rel="noopener" href="https://github.com/jpush/jpush-flutter-plugin">https://github.com/jpush/jpush-flutter-plugin</a> <a target="_blank" rel="noopener" href="https://pub.dev/packages/jpush_flutter">https://pub.dev/packages/jpush_flutter</a></p>
<p>参考《Flutter Native》 Flutter 在 Android 中实现消息推送、设置别名 指定设备推送</p>
<p><strong>50****、如何在</strong> <strong>Flutter</strong> <strong>中实现一键登录</strong></p>
<p>获取到当前手机使用的手机卡号，直接使用这个号码进行注册、登录，这就是一键登录。</p>
<p>可以借助极光官方的极光认证实现</p>
<p>1、注册账户成为开发者</p>
<p>2、创建应用开通极光认证 （注意开通极光认证要通过实名审核）</p>
<p>3、创建应用获取 appkey、 Master Secret</p>
<p>4、开通一键登录功能 提交审核</p>
<p>5、flutter 中集成 jverify 插件</p>
<p>6、根据 App 一键登录成功后返回的 loginToken 获取手机号（需求请求后端接口）</p>
<p>参考《Flutter Native》一键登录</p>
<p><strong>51****、分享一些你在</strong> <strong>Flutter</strong> <strong>项目中遇到的挑战和解决方案</strong></p>
<p>面试官通过这个问题就能知道开发者的水平怎么样，所以需要注意回答的方式。</p>
<p>1、适配不同屏幕尺寸、请求接口渲染数据、性能优化、状态管理 这些的话做过很多次，不</p>
<p>算有挑战的技术 </p>
<p>（<strong>这样回答可以让面试官知道你懂这些</strong>）</p>
<p>2、记得以前项目中遇到比较麻烦和有挑战的</p>
<p>(1) 需求的变化、代码重构和维护、适应市场部门推广来回改需求，这个比较麻烦</p>
<p>(2) 再就是研究 Flutter 蓝牙、 FLutter wifi 物联网模块通信的时候稍微有点难度，涉及</p>
<p>的知识比较多，得慢慢调试(3) 做微信支付的时候也比较麻烦，比如 Android 需要正式打包调试（后面查资料知道</p>
<p>可以配置签名），Ios15 以后需要配置 universalLink</p>
<p>2、极光推送 极光一键登录 这些刚开始集成的时候都是比较麻烦的，android 还好，ios 还</p>
<p>需配置正式之类的</p>
<p><strong>说明：</strong>根据自己的实际情况回答，要让面试官知道你会的东西多，还不能让面试官觉得你菜</p>
<p><strong>52<strong><strong>、</strong></strong>Flutter</strong> <strong>的性能分析工具用过吗，如何用</strong></p>
<p>Flutter 提供了一些性能分析工具，如 Flutter DevTools 和 DartDevTools。这些工具可以帮助找出性能瓶颈，从而进行</p>
<p>针对性的优化。例如，使用 Flutter DevTools 的 Timeline 视图来查看应用的帧率，以及每一帧的构建、布局和绘制时</p>
<p>间；还可以使用 Dart DevTools 的 CPU 分析器来查看 CPU 的使用情况，以及每个函数的执行时间。</p>
<p><strong>打开</strong> <strong>DevTools</strong> <strong>的方法</strong></p>
<p>1、flutter run 的时候通过提示的地址查看 调试性能</p>
<p>2、Vscode 中创建 launch.json 进行调试 、好处可以选择模式</p>
<p><strong>方法</strong> <strong>1****：</strong> <strong>flutter run</strong> <strong>的时候通过提示的地址查看性能****方法二</strong> <strong>Vscode</strong> <strong>中创建</strong> <strong>launch.json</strong> <strong>进行调试</strong> </p>
<p><strong>好处可以选择模式<strong><strong>53</strong></strong>、****Dart</strong> <strong>语言</strong> <strong>final</strong> <strong>和</strong> <strong>const</strong> <strong>有什么不同？</strong></p>
<p>1、const 声明的常量是在编译时确定的，永远不会改变</p>
<p>2、final 声明的常量允许声明后再赋值，赋值后不可改变，final 声明的变量是在运行时确</p>
<p>定的;</p>
<p>3、final 不仅有 const 的编译时常量的特性，最重要的它是运行时常量，并且 final 是惰性初</p>
<p>始化，即在运行时第一次使用前才初始化</p>
<p>4、Flutter 静态组件上面加上 Const 可以优化程序性能，实例化常量构造函数的时候，多个</p>
<p>地方创建这个对象，如果传入的值相同，只会保留一个对象。</p>
<p>final a;</p>
<p>a&#x3D;13;</p>
<p>print(a);</p>
<p>final d&#x3D;new DateTime.now();</p>
<p>const c &#x3D; 10;</p>
<p><strong>54<strong><strong>、</strong></strong>Dart</strong> <strong>语言</strong> <strong>var<strong><strong>、</strong></strong>final<strong><strong>、</strong></strong>const<strong><strong>、</strong></strong>late</strong> <strong>介绍</strong></p>
<p>var：var 声明的变量可以在运行时改变其值。</p>
<p>final：final 声明的常量的值在初始化后不能被改变。final 声明的变量是在运行时确定的;</p>
<p>const：const 声明的变量是常量，其值不能在运行时改变。const 变量在声明时必须被初始化。</p>
<p>late：late 声明的变量可以在初始化前使用。定义类的属性要延迟初始化的话就可以加 late</p>
<p>void main() {</p>
<p>&#x2F;&#x2F; 使用 var 声明变量</p>
<p>var a &#x3D; 10; </p>
<p>a &#x3D; 20;</p>
<p>&#x2F;&#x2F; 使用 final 声明常量</p>
<p>final b &#x3D; 10;&#x2F;&#x2F; b &#x3D; 20; 这行代码会产生错误，因为 final 变量的值不能被改变</p>
<p>&#x2F;&#x2F; 使用 const 声明变量</p>
<p>const c &#x3D; 10;</p>
<p>&#x2F;&#x2F; c &#x3D; 20; 这行代码会产生错误，因为 const 变量的值不能被改变</p>
<p>&#x2F;&#x2F; 使用 late 声明变量</p>
<p>late d;</p>
<p>d &#x3D; 20;</p>
<p>}</p>
<p><strong>55<strong><strong>、</strong></strong>Dart</strong> <strong>中有哪些访问修饰符？</strong></p>
<p>在 Dart 中，有以下几种访问修饰符：</p>
<p>默认访问修饰符（No modifier）：如果没有显式地指定访问修饰符，则默认为包内可见</p>
<p>（package-private），即同一个包内的其他文件可以访问。</p>
<p>public：在 Dart 中，默认情况下，所有的成员（变量、函数、类等）都是公开的，即可在</p>
<p>任何地方访问。公开成员不使用任何访问修饰符进行标识。</p>
<p>_private：使用下划线 _ 开头的标识符表示私有成员，只能在当前文件中访问。私有成员在</p>
<p>其他文件中是不可见的。</p>
<p><strong>例如，下面是一个示例类，演示了访问修饰符的使用：</strong></p>
<p>class Person {</p>
<p>String name; &#x2F;&#x2F; 默认访问修饰符，默认为包内可见</p>
<p>int _age; &#x2F;&#x2F; 私有成员，只能在当前文件中访问</p>
<p>void sayHello() {</p>
<p>print(‘Hello, $name!’);</p>
<p>}</p>
<p>int _calculateAge() {</p>
<p>&#x2F;&#x2F; 私有方法，只能在当前文件中访问</p>
<p>&#x2F;&#x2F; … </p>
<p>}</p>
<p>}</p>
<p>在上述示例中，name 是一个默认访问修饰符的成员，可以在同一个包内的其他文件中访问。</p>
<p>_age 是一个私有成员，只能在当前文件中访问。sayHello() 是一个公开的方法，可以在任何地方访问。_calculateAge() 是一个私有方法，只能在当前文件中访问。</p>
<p>需要注意的是，Dart 中没有像 Java 那样的 public 和 private 关键字来显式地标识访问修</p>
<p>饰符。默认情况下，成员是公开的，使用下划线 _ 开头的标识符表示私有成员。</p>
<p><strong>56<strong><strong>、</strong></strong>Dart</strong> <strong>语言 命名参数、可选参数 是什么</strong></p>
<p>在 Dart 语言中，命名参数（Named Parameters）和可选参数（Optional Parameters）是用于定义函数接受</p>
<p>参数的方式。</p>
<p>定义一个带可选参数的方法 ，最新的 dart 定义可选参数需要指定类型默认值</p>
<p>String printUserInfo(String username,[int age&#x3D;0]){ &#x2F;&#x2F;行参</p>
<p>if(age!&#x3D;0){ </p>
<p>return “姓名:$username—年龄:$age”;</p>
<p>}</p>
<p>return “姓名:$username—年龄保密”;</p>
<p>}</p>
<p>print(printUserInfo(‘张三’,21)); &#x2F;&#x2F;实参</p>
<p>print(printUserInfo(‘张三’));</p>
<p>定义一个命名参数的方法，最新的 dart 定义命名参数需要指定类型默认值</p>
<p>String printUserInfo(String username, {int age &#x3D; 0, String sex &#x3D; ‘男’}) {&#x2F;&#x2F;行参</p>
<p>if (age !&#x3D; 0) { </p>
<p>return “姓名:$username—性别:$sex–年龄:$age”;</p>
<p>}</p>
<p>return “姓名:$username—性别:$sex–年龄保密”;</p>
<p>}</p>
<p>print(printUserInfo(‘张三’, age: 20, sex: ‘未知’));</p>
<p><strong>57<strong><strong>、</strong></strong>Dart</strong> <strong>语言命名构造函数和工厂函数之间有什么区别</strong></p>
<p>在 Dart 语言中，命名构造函数（Named Constructors）和工厂函数（Factory Constructors）</p>
<p>是两种用于创建对象的不同方式，它们有以下区别：<strong>1****、命名构造函数</strong>：命名构造函数是在类中定义的特殊构造函数，通过使用类名后跟一个句</p>
<p>点和构造函数名称来定义。命名构造函数用于提供不同的构造方式或创建具有特定初始化逻</p>
<p>辑的对象。</p>
<p>class Person {</p>
<p>String name;</p>
<p>int age;</p>
<p>&#x2F;&#x2F; 默认构造函数</p>
<p>Person(this.name, this.age);</p>
<p>&#x2F;&#x2F; 命名构造函数</p>
<p>Person.fromBirthYear(this.name, int birthYear) { </p>
<p>age &#x3D; DateTime.now().year - birthYear;</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F; 使用默认构造函数创建对象</p>
<p>var john &#x3D; Person(‘John’, 30);</p>
<p>&#x2F;&#x2F; 使用命名构造函数创建对象</p>
<p>var alice &#x3D; Person.fromBirthYear(‘Alice’, 1995);</p>
<p>3、<strong>工厂函数</strong>：工厂函数是通过使用 factory 关键字定义的特殊构造函数，用于创建对象的</p>
<p>灵活方式。工厂函数可以返回一个新的对象，也可以返回一个已存在的对象。工厂函数通常</p>
<p>用于创建单例对象或根据特定条件决定返回哪个对象。</p>
<p>class Logger {</p>
<p>String name; </p>
<p>static Logger _instance;</p>
<p>&#x2F;&#x2F; 私有构造函数</p>
<p>Logger._internal(this.name);</p>
<p>&#x2F;&#x2F; 工厂函数</p>
<p>factory Logger(String name) {</p>
<p>if (_instance &#x3D;&#x3D; null) { </p>
<p>_instance &#x3D; Logger._internal(name);</p>
<p>}</p>
<p>return _instance;</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F; 使用工厂函数创建对象</p>
<p>var logger1 &#x3D; Logger(‘Logger 1’); </p>
<p>var logger2 &#x3D; Logger(‘Logger 2’);</p>
<p>在上述示例中，Logger 类定义了一个工厂函数 Logger，用于创建 Logger 对象。工厂函数通过判断是否已</p>
<p>存在对象，来决定返回一个新的对象或一个已存在的对象。这种方式可以实现单例模式，确保只有一个Logger 对象被创建。</p>
<p>命名构造函数用于提供不同的构造方式或初始化逻辑，而工厂函数用于提供创建对象的灵活方式，可以返</p>
<p>回新的对象或已存在的对象。</p>
<p><strong>58<strong><strong>、</strong></strong>Dart</strong> <strong>中的</strong> <strong>Object<strong><strong>、</strong></strong>dynamic</strong> <strong>和</strong> <strong>var</strong> <strong>有何不同？</strong></p>
<p>Object 是所有类的基类，可以表示任何对象。</p>
<p>dynamic 是一种动态类型，可以在运行时具有任何类型的值，但缺乏静态类型检查。</p>
<p>var 是一种通过值推断类型的关键字，具有静态类型检查，类型在编译时确定并不可更改。</p>
<p>void main() {</p>
<p>Object obj &#x3D; ‘Hello’; &#x2F;&#x2F; Object 类型变量可以存储任何对象</p>
<p>print(obj.toString()); &#x2F;&#x2F; 使用 Object 类型的变量调用通用方法</p>
<p>dynamic dynamicVar &#x3D; 10; &#x2F;&#x2F; dynamic 类型变量可以具有任何类型的值</p>
<p>dynamicVar &#x3D; ‘World’; &#x2F;&#x2F; 可以将不同类型的值赋给 dynamic 类型的变量</p>
<p>print(dynamicVar.length); &#x2F;&#x2F; 在运行时执行操作，编译器不会进行类型检查</p>
<p>var varVar &#x3D; 3.14; &#x2F;&#x2F; 根据初始值推断变量类型为 double</p>
<p>&#x2F;&#x2F; varVar &#x3D; ‘Dart’; &#x2F;&#x2F; 不能将不同类型的值赋给 var 类型的变量</p>
<p>print(varVar.toDouble()); &#x2F;&#x2F; 编译器进行静态类型检查</p>
<p>}</p>
<p><strong>59<strong><strong>、</strong></strong>Dart Flutter</strong> <strong>中如何定义私有方法和私有属性</strong></p>
<p>Dart 和其他面向对象语言不一样，Data 中没有 public private protected 这些访问修饰符合</p>
<p>但是我们可以使用_把一个属性或者方法定义成私有。</p>
<p>class Animal {</p>
<p>String _name; &#x2F;&#x2F;私有属性</p>
<p>int age;</p>
<p>Animal(this._name, this.age); </p>
<p>void printInfo() {</p>
<p>print(“${this._name}—-${this.age}”);</p>
<p>}</p>
<p>String getName() { </p>
<p>return this._name;</p>
<p>}</p>
<p>void _run() {</p>
<p>print(‘这是一个私有方法’);</p>
<p>}</p>
<p>}<strong>60<strong><strong>、</strong></strong>Dart</strong> <strong>中的</strong> <strong>Getter</strong> <strong>和</strong> <strong>Setter</strong></p>
<p>getter 和 setter 方法是用于操作类字段数据的类方法。getter 用于读取或获取类字段的数据，而 setter 用</p>
<p>于将类字段的数据设置为某个变量。</p>
<p><strong>61<strong><strong>、</strong></strong>Dart Flutter</strong> <strong>中如何定义和实现接口</strong></p>
<p>1、接口就是约定和规范</p>
<p>2、dart 接口不是使用的 interface 关键字，而是使用抽象类定义接口。</p>
<p>3、使用 implements 关键字进行实现接口。</p>
<p>实例： 定义一个 DB 库 支持 mysql mssql mongodb，使用接口实现</p>
<p>abstract class Db {</p>
<p>&#x2F;&#x2F;当做接口 </p>
<p>接口：就是约定 、规范</p>
<p>late String uri; </p>
<p>add(String data); </p>
<p>save();</p>
<p>delete();</p>
<p>}</p>
<p>class Mysql implements Db {</p>
<p>class Rect { </p>
<p>num height; </p>
<p>num width;</p>
<p>Rect(this.height, this.width);</p>
<p>get area { </p>
<p>return this.height * this.width;</p>
<p>}</p>
<p>set areaHeight(value) {</p>
<p>this.height &#x3D; value;</p>
<p>}</p>
<p>}</p>
<p>void main() {</p>
<p>Rect r &#x3D; new Rect(10, 4);</p>
<p>print(“面积:${r.area()}”); </p>
<p>r.areaHeight &#x3D; 6;</p>
<p>print(r.area);</p>
<p>}@override</p>
<p>String uri;</p>
<p>Mysql(this.uri);</p>
<p>@override</p>
<p>add(data) {</p>
<p>print(‘这是 mysql 的 add 方法’ + data);</p>
<p>}</p>
<p>@override </p>
<p>delete() { </p>
<p>return null;</p>
<p>}</p>
<p>@override</p>
<p>save() { </p>
<p>return null;</p>
<p>}</p>
<p>remove() {}</p>
<p>}</p>
<p>class MsSql implements Db {</p>
<p>@override</p>
<p>late String uri;</p>
<p>@override</p>
<p>add(String data) {</p>
<p>print(‘这是 mssql 的 add 方法’ + data);</p>
<p>}</p>
<p>@override </p>
<p>delete() { </p>
<p>return null;</p>
<p>}</p>
<p>@override</p>
<p>save() { </p>
<p>return null;</p>
<p>}</p>
<p>}</p>
<p>main() {</p>
<p>Mysql mysql &#x3D; new Mysql(‘xxxxxx’); </p>
<p>mysql.add(‘1243214’);</p>
<p>}<strong>62<strong><strong>、</strong></strong>Dart Flutter</strong> <strong>空安全是什么</strong></p>
<p>Null safety 翻译成中文的意思是空安全。</p>
<p>null safety 可以帮助开发者避免一些日常开发中很难被发现的错误，并且额外的好处是可以改善性能。</p>
<p>Flutter2.2.0（2021 年 5 月 19 日发布） 之后的版本都要求使用 null safety。</p>
<p>? 可空类型</p>
<p>! 类型断言</p>
<p>main() {</p>
<p>String? str &#x3D; “this is str”; </p>
<p>str &#x3D; null;</p>
<p>print(str!.length);</p>
<p>}</p>
<p><strong>63****、你能解释一下在</strong> <strong>Flutter</strong> <strong>中</strong> <strong>key****（键）的作用吗</strong></p>
<p><strong>1****、</strong>在 Flutte 中 Key 一般用来做唯一标识，正常开发中是不需要设置 <strong>Key</strong> <strong>的。</strong></p>
<p>2、在大多数情况下，Flutter 可以自动处理 Widget 小部件树的更新和重建，而无需显式地使用 Key。只有</p>
<p>在特定情况下，如动态列表、Widget 小部件重用或需要保留状态时，才需要使用 Key。</p>
<p>3、通过 key 可以获取组件的信息，比如：globalKey.currentState 可以获取子组件的状态，执行子组件的方</p>
<p>法，globalKey.currentWidget 可以获取子组件的属性，_globalKey.currentContext!.findRenderObject()可以获取</p>
<p>渲染的属性。</p>
<p>在 Flutter 中，Key 是不能重复使用的，<strong>所以</strong> <strong>Key</strong> <strong>一般用来做唯一标识</strong>。组件在更新的时候，其状态的保</p>
<p>存主要是通过判断组件的类型或者 key 值是否一致。因此，当各组件的类型不同的时候，类型已经足够</p>
<p>用来区分不同的组件了，此时我们可以不必使用 key。但是如果同时存在多个同一类型的控件的时候，</p>
<p>此时类型已经无法作为区分的条件了，我们就需要使用到 key。</p>
<p><strong>64****、在</strong> <strong>Flutter</strong> <strong>中，<strong><strong>Keys</strong></strong>（键）有哪几种类型</strong></p>
<p>Flutter key 子类包含 LocalKey 和 GlobalKey 。</p>
<p><strong>LocalKey****（局部键）：</strong></p>
<p><strong>ValueKey</strong>：使用特定的值作为标识符，可以是数字、字符串或其他可比较的对象。例如，ValueKey(1) 或</p>
<p>ValueKey(‘myKey’)。</p>
<p><strong>ObjectKey</strong>：使用对象作为标识符，使用对象的引用进行识别和比较。例如，ObjectKey(myObject)。</p>
<p><strong>UniqueKey</strong>：生成全局唯一的标识符，用于确保在每次重建时都会创建新的小部件实例。例如，UniqueKey()。ListView( </p>
<p>children: [</p>
<p>ListTile(</p>
<p>key: ValueKey(1), </p>
<p>title: Text(‘Item 1’), </p>
<p>),</p>
<p>ListTile(</p>
<p>key: ObjectKey(myObject), </p>
<p>title: Text(‘Item 2’), </p>
<p>),</p>
<p>ListTile(</p>
<p>key: UniqueKey(), </p>
<p>title: Text(‘Item 3’), </p>
<p>), </p>
<p>], </p>
<p>);</p>
<p><strong>GlobalKey****（全局键）</strong>： GlobalKey 是 LocalKey 的一个特殊子类，用于在整个应用程序中跨小部件树进行</p>
<p>引用和识别。通过 GlobalKey，可以直接访问关联小部件的状态和方法。</p>
<p>以下是 GlobalKey 的示例：</p>
<p>import ‘package:flutter&#x2F;material.dart’; </p>
<p>void main() {</p>
<p>runApp(const MyApp());</p>
<p>}</p>
<p>class MyApp extends StatelessWidget { </p>
<p>const MyApp({Key? key}) : super(key: key);</p>
<p>&#x2F;&#x2F; This widget is the root of your application. </p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>return MaterialApp(</p>
<p>title: ‘Flutter Demo’, </p>
<p>theme: ThemeData(</p>
<p>primarySwatch: Colors.blue, </p>
<p>), </p>
<p>home: const HomePage(), </p>
<p>);</p>
<p>}}</p>
<p>class HomePage extends StatefulWidget { </p>
<p>const HomePage({super.key});</p>
<p>@override </p>
<p>State<HomePage> createState() &#x3D;&gt; _HomePageState();</p>
<p>}</p>
<p>class _HomePageState extends State<HomePage> {</p>
<p>final GlobalKey _globalKey &#x3D; GlobalKey();</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>return Scaffold(</p>
<p>floatingActionButton: FloatingActionButton( </p>
<p>child: const Icon(Icons.add), </p>
<p>onPressed: (){</p>
<p>&#x2F;&#x2F;1、获取子组件的状态 调用子组件的属性</p>
<p>var state&#x3D;(_globalKey.currentState as _BoxState); </p>
<p>setState(() { </p>
<p>state._count++;</p>
<p>});</p>
<p>&#x2F;&#x2F;2、获取子组件的属性</p>
<p>var box&#x3D;(_globalKey.currentWidget as Box);</p>
<p>print(box.color);</p>
<p>&#x2F;&#x2F;3、获取子组件渲染的属性</p>
<p>var renderBox&#x3D; (_globalKey.currentContext!.findRenderObject() as RenderBox);</p>
<p>print(renderBox.size);</p>
<p>}, </p>
<p>), </p>
<p>appBar: AppBar(</p>
<p>title: const Text(‘Title’), </p>
<p>), </p>
<p>body: Center( </p>
<p>child: Box(</p>
<p>key: _globalKey, </p>
<p>color: Colors.red, </p>
<p>), </p>
<p>), </p>
<p>);</p>
<p>}}</p>
<p>class Box extends StatefulWidget {</p>
<p>final Color color; </p>
<p>const Box({Key? key, required this.color}):super(key: key);</p>
<p>@override </p>
<p>State<Box> createState() &#x3D;&gt; _BoxState();</p>
<p>}</p>
<p>class _BoxState extends State<Box> {</p>
<p>int _count &#x3D; 0; </p>
<p>run(){</p>
<p>print(“run”);</p>
<p>}</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>return SizedBox(</p>
<p>height: 100, </p>
<p>width: 100, </p>
<p>child: ElevatedButton( </p>
<p>style: ButtonStyle(</p>
<p>backgroundColor: MaterialStateProperty.all(widget.color)), </p>
<p>onPressed: () { </p>
<p>setState(() { </p>
<p>_count++;</p>
<p>});</p>
<p>}, </p>
<p>child: Center( </p>
<p>child: Text(“$_count”), </p>
<p>), </p>
<p>), </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p>参考：《第二十九讲》<strong>65<strong><strong>、</strong></strong>Flutter GetX</strong> <strong>中</strong> <strong>onInit</strong> <strong>没法触发是什么原因</strong></p>
<p>GetX 中 onInit 没法触发主要原因是页面上面没有绑定 Obx 响应式数据</p>
<p><strong>66<strong><strong>、</strong></strong>Flutter GetX</strong> <strong>相比其他的状态管理有什么优势</strong></p>
<p>现在 Flutter 的状态管理方案很多，redux、bloc、state、provider、Getx。</p>
<p>Getx 不仅具有状态管理的功能，还具有路由管理、主题管理、国际化多语言管理、Obx 局部更新、网络请求、数据验</p>
<p>证等功能，相比其他状态管理插件 Getx 简单、功能强大并且高性能。 </p>
<p><strong>67<strong><strong>、</strong></strong>Flutter Getx</strong> <strong>绑定数据的几种方法</strong></p>
<p><strong>方法一、****Obx</strong> <strong>绑定</strong></p>
<p>Obx(()&#x3D;&gt;Text(“${countController.count}”,style: Theme.of(context).textTheme.headline1)), </p>
<p><strong>方法二、</strong>GetBuilder <strong>绑定</strong></p>
<p>GetBuilder<CountController>(</p>
<p>init: countController, </p>
<p>builder: (controller) {</p>
<p>return Text(</p>
<p>“${controller.count}”, </p>
<p>style: const TextStyle(color: Colors.green, fontSize: 30), </p>
<p>);</p>
<p>}, </p>
<p>)</p>
<p><strong>方法三、</strong>getx 方式绑定 （用不到）</p>
<p>GetX<CountController>(</p>
<p>init: CountController(), </p>
<p>builder: (controller) {</p>
<p>return Text(</p>
<p>“${controller.count}”, </p>
<p>style: const TextStyle(color: Colors.green, fontSize: 30), </p>
<p>);</p>
<p>}, </p>
<p>),<strong>68<strong><strong>、</strong></strong>Flutter GetX</strong> <strong>中</strong> <strong>obx</strong> <strong>和</strong> <strong>getBuild</strong> <strong>有什么区别</strong></p>
<p>写项目的时候 obx 用的更多一些，getBuild 也会用到，tab 切换里面挂载的页面，进行 tab 切换默认不会触发每个页</p>
<p>面的 onInit 方法，这个时候如果想进入到某个页面更新数据的时候，就可以用到 getBuild 。</p>
<p>obx 提供了更简洁、便捷和性能优化的方式来观察和更新状态，特别适用于小规模的状态管理和局部 UI 更新。而</p>
<p>GetBuilder 则更适合于需要手动控制重绘粒度或更复杂的状态管理场景</p>
<p><strong>obx</strong> <strong>例子</strong></p>
<p>import ‘package:flutter&#x2F;material.dart’;</p>
<p>import ‘package:get&#x2F;get.dart’;</p>
<p>&#x2F;&#x2F; 创建一个控制器类</p>
<p>class MyController extends GetxController { </p>
<p>var count &#x3D; 0.obs; &#x2F;&#x2F; 使用.obs 将 count 变为可观察的（Observable）</p>
<p>void increment() { </p>
<p>count.value++; &#x2F;&#x2F; 修改可观察变量的值</p>
<p>}</p>
<p>}</p>
<p>void main() {</p>
<p>runApp(MyApp());</p>
<p>}</p>
<p>class MyApp extends StatelessWidget {</p>
<p>final MyController controller &#x3D; Get.put(MyController()); &#x2F;&#x2F; 注入控制器</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>return GetMaterialApp(</p>
<p>home: Scaffold( </p>
<p>appBar: AppBar(</p>
<p>title: Text(‘GetX obx Example’), </p>
<p>), </p>
<p>body: Center( </p>
<p>child: Column( </p>
<p>mainAxisAlignment: MainAxisAlignment.center, </p>
<p>children: [</p>
<p>&#x2F;&#x2F; 使用 obx 观察和更新状态</p>
<p>Obx(() &#x3D;&gt; Text(</p>
<p>‘Count: ${controller.count.value}’, &#x2F;&#x2F; 获取可观察变量的值</p>
<p>style: TextStyle(fontSize: 24),)), </p>
<p>SizedBox(height: 16), </p>
<p>ElevatedButton( </p>
<p>onPressed: () { </p>
<p>controller.increment(); &#x2F;&#x2F; 调用控制器的方法来更新状态</p>
<p>}, </p>
<p>child: Text(‘Increment’), </p>
<p>), </p>
<p>], </p>
<p>), </p>
<p>), </p>
<p>), </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p><strong>getBuilder</strong> <strong>例子</strong></p>
<p>import ‘package:flutter&#x2F;material.dart’;</p>
<p>import ‘package:get&#x2F;get.dart’;</p>
<p>&#x2F;&#x2F; 创建一个控制器类</p>
<p>class MyController extends GetxController { </p>
<p>var count &#x3D; 0; </p>
<p>void increment() { </p>
<p>count++; </p>
<p>update(); &#x2F;&#x2F; 手动触发 UI 更新</p>
<p>}</p>
<p>}</p>
<p>void main() {</p>
<p>runApp(MyApp());</p>
<p>}</p>
<p>class MyApp extends StatelessWidget {</p>
<p>final MyController controller &#x3D; Get.put(MyController()); &#x2F;&#x2F; 注入控制器</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>return GetMaterialApp(</p>
<p>home: Scaffold( </p>
<p>appBar: AppBar(</p>
<p>title: Text(‘GetX GetBuilder Example’), </p>
<p>), </p>
<p>body: Center( </p>
<p>child: Column( </p>
<p>mainAxisAlignment: MainAxisAlignment.center, </p>
<p>children: [&#x2F;&#x2F; 使用 GetBuilder 观察和更新状态</p>
<p>GetBuilder<MyController>(</p>
<p>initState: (state) {</p>
<p>&#x2F;&#x2F;获取购物车数据</p>
<p>}, </p>
<p>init: controller, </p>
<p>builder: (controller) &#x3D;&gt; Text(</p>
<p>‘Count: ${controller.count}’, &#x2F;&#x2F; 获取控制器的属性值</p>
<p>style: TextStyle(fontSize: 24), </p>
<p>), </p>
<p>),</p>
<p>SizedBox(height: 16), </p>
<p>ElevatedButton( </p>
<p>onPressed: () { </p>
<p>controller.increment(); &#x2F;&#x2F; 调用控制器的方法来更新状态</p>
<p>}, </p>
<p>child: Text(‘Increment’), </p>
<p>), </p>
<p>], </p>
<p>), </p>
<p>), </p>
<p>), </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p><strong>69****、</strong> <strong>Flutter Sliver</strong> <strong>是什么解决了什么问题</strong></p>
<p>在 Flutter 中，Sliver 是用于构建灵活和高性能滚动效果的组件。</p>
<p><strong>Sliver</strong> <strong>解决了以下问题：</strong></p>
<p>1、<strong>可变大小的滚动元素</strong>：传统的滚动组件（如 ListView）中的每个子项都具有固定的高度，</p>
<p>这限制了滚动元素的灵活性。而 Sliver 允许每个子项具有不同的高度，从而实现了可变大小</p>
<p>的滚动元素。这对于需要动态调整高度的元素（如可伸缩的标题、动态列表项等）非常有用。</p>
<p>2、<strong>交互式滚动效果</strong>：Sliver 允许在滚动过程中实现交互式效果和动画。你可以根据滚动位置</p>
<p>或其他条件来控制 Sliver 中的内容，例如淡入淡出效果、透明度变化、放大缩小效果等。这</p>
<p>为创建吸顶效果、悬浮按钮、展开折叠效果等提供了便利。</p>
<p>3、<strong>高性能滚动</strong>：使用 Sliver 构建的滚动效果可以提供更好的性能。Sliver 通过延迟构建和回</p>
<p>收不可见的元素，以及只构建可见元素来减少内存占用和渲染开销。这在处理大数据集或具有复杂布局的滚动视图时特别有用。</p>
<p>4、<strong>灵活的自定义</strong>：Sliver 提供了强大的自定义能力，允许你根据需要定制滚动效果。你可以</p>
<p>根据自己的需求创建自定义的 Sliver 组件，实现各种复杂的滚动效果和交互。</p>
<p><strong>代码示例</strong></p>
<p>CustomScrollView( </p>
<p>slivers: <Widget>[</p>
<p>SliverAppBar(</p>
<p>&#x2F;&#x2F; 在滚动时隐藏&#x2F;显示标题栏</p>
<p>title: Text(‘Sliver Demo’), </p>
<p>floating: true, </p>
<p>&#x2F;&#x2F; 其他 SliverAppBar 属性… </p>
<p>), </p>
<p>SliverList(</p>
<p>delegate: SliverChildBuilderDelegate(</p>
<p>(BuildContext context, int index) {</p>
<p>&#x2F;&#x2F; 构建列表项</p>
<p>return ListTile(</p>
<p>title: Text(‘Item $index’), </p>
<p>);</p>
<p>}, </p>
<p>childCount: 20, </p>
<p>), </p>
<p>), </p>
<p>], </p>
<p>)</p>
<p><strong>70****、</strong> <strong>Flutter Listview</strong> <strong>如何嵌套</strong> <strong>GridView</strong></p>
<p>可以在 GridView 中加入 shrinkWrap</p>
<p>GridView.builder( </p>
<p>shrinkWrap: true, &#x2F;&#x2F;收缩</p>
<p>itemCount: 8, &#x2F;&#x2F;必须设置</p>
<p>… </p>
<p>）<strong>71****、</strong> <strong>Flutter Tab</strong> <strong>切换的时候如何保持页面滚动条的状态</strong></p>
<p>可以通过 with AutomaticKeepAliveClientMixin 实现</p>
<p>import ‘package:flutter&#x2F;material.dart’; </p>
<p>class KeepAliveWrapper extends StatefulWidget { </p>
<p>const KeepAliveWrapper(</p>
<p>{Key? key, @required this.child, this.keepAlive &#x3D; true})</p>
<p>: super(key: key);</p>
<p>final Widget? child;</p>
<p>final bool keepAlive;</p>
<p>@override </p>
<p>State<KeepAliveWrapper> createState() &#x3D;&gt; _KeepAliveWrapperState();</p>
<p>}</p>
<p>class _KeepAliveWrapperState extends State<KeepAliveWrapper> </p>
<p>with AutomaticKeepAliveClientMixin {</p>
<p>@override </p>
<p>Widget build(BuildContext context) {</p>
<p>return widget.child!;</p>
<p>}</p>
<p>@override </p>
<p>bool get wantKeepAlive &#x3D;&gt; widget.keepAlive;</p>
<p>}</p>
<p><strong>72****、 国内那些应用是</strong> <strong>flutter</strong> <strong>开发的</strong></p>
<p>闲鱼都是毫无悬念的最重度使用 Flutter 开发的应用，淘特、UC 浏览器、携程 都是重度使</p>
<p>用 flutter 的,腾讯的很多产品包里面也有 flutter 的痕迹，QQ 邮箱、百度网盘都有使用 flutter</p>
<p>现在如果你找个主流的应用商店，把其中排名靠前的 100 个非游戏类 App 找出来。至少能</p>
<p>有 30 个以上的 App 是使用了 Flutter 开发的。<strong>73****、</strong> <strong>Flutter JSON</strong> <strong>字符串和</strong> <strong>Map</strong> <strong>类型的转换</strong></p>
<p><strong>一、****Flutter Map</strong> <strong>转换成</strong> <strong>Json</strong></p>
<p>import ‘dart:convert’ </p>
<p>Map userInfo&#x3D;{ </p>
<p>“username”:”张三”, </p>
<p>“age”:20</p>
<p>};</p>
<p>print(json.encode(userInfo));</p>
<p><strong>二、****Flutter Json</strong> <strong>转换成</strong> <strong>Map</strong></p>
<p>String str&#x3D;’{“username”:”张三”,”age”:20}’;</p>
<p>print(json.decode(str));</p>
<p>Map info&#x3D;json.decode(str);</p>
<p>print(info[“username”]);</p>
<p><strong>74****、</strong> <strong>Flutter</strong> <strong>中如何自定义字体图标</strong></p>
<p>可以借助阿里巴巴图标库自定义字体图标</p>
<p>参考: <a target="_blank" rel="noopener" href="http://bbs.itying.com/topic/638ae6a33fd95910e036af80">http://bbs.itying.com/topic/638ae6a33fd95910e036af80</a></p>
<p><strong>75****、</strong> <strong>Flutter TabBar TabBarView</strong> <strong>禁止左右滑动</strong></p>
<p>要在 Flutter TabBar TabBarView 中禁止左右滑动的话我们只需要配置</p>
<p>physics: NeverScrollableScrollPhysics()</p>
<p>详细代码：</p>
<p>TabBarView(</p>
<p>physics: NeverScrollableScrollPhysics(), &#x2F;&#x2F;禁止滑动</p>
<p>children: <Widget>[</p>
<p>ProductContentFirst(this._productContentList), </p>
<p>ProductContentSecond(this._productContentList), </p>
<p>ProductContentThird()</p>
<p>], </p>
<p>)<strong>76****、</strong> <strong>Flutter</strong> <strong>第三方库命名冲突如何解决</strong></p>
<p>Flutter 第三方库命名冲突的话我们可以引入的时候通过 as 指定名称</p>
<p>如下：</p>
<p>import ‘package:date_format&#x2F;date_format.dart’ as DateFormat;</p>
<p><strong>77****、</strong> <strong>Flutter run</strong> <strong>或者下载依赖的时候遇到卡死的情况如何解决</strong></p>
<p>这个可能是网络引起的，正常不会出现的，出现后手机开启热点试试，如果还是不行就配置</p>
<p>一下镜像源</p>
<p>参考：<a target="_blank" rel="noopener" href="http://bbs.itying.com/topic/5d6fa4682a95ee138cf28d2c">http://bbs.itying.com/topic/5d6fa4682a95ee138cf28d2c</a></p>
<p><strong>78****、</strong> <strong>flutter initState</strong> <strong>中获取</strong> <strong>context</strong> <strong>对象</strong></p>
<p>flutter initState 中获取 context 对象，这个时候可以使用 this.context。</p>
<p>flutter initState 中获取 context 对象完整实例：</p>
<p>void initState() {</p>
<p>super.initState();</p>
<p>var context&#x3D;this.context;</p>
<p>this._attrBottomSheet(context);</p>
<p>}</p>
<p><strong>79****、</strong> <strong>Dart</strong> <strong>是不是单线程模型</strong></p>
<p>Dart 是单线程语言，它是基于单线程加事件循环来完成耗时操作的处理，</p>
<p>Dart 可以通过 isolate 并发模型实现类似多线程的功能</p>
<p><strong>80****、</strong> <strong>Dart Flutter</strong> <strong>中如何实现多线程</strong></p>
<p>Dart 是单线程语言，在 Dart 中，没有多线程。Dart 的单线程模型和异步编程工具已经能</p>
<p>够满足常见的并发需求。但是我们可以使用异步模拟多线程或者使用 isolate 并发模型实现类似多线程的功能</p>
<p>方法 1：利用异步，模拟多线程</p>
<p>方法 2: 利用 dart:isolate 实现</p>
<p>输出：</p>
<p>end</p>
<p>4950</p>
<p>499999500000</p>
<p><strong>81****、</strong> <strong>Dart Flutter</strong> <strong>中</strong> <strong>isolate</strong> <strong>机制</strong></p>
<p>Isolate 是 Dart 中一种轻量级的线程模型，用于在 Dart 应用程序中实现并发执行和隔离。</p>
<p>Isolate 允许在同一个进程内创建多个独立的执行上下文，每个 Isolate 都有自己的堆内存和</p>
<p>栈内存，并且可以独立地执行 Dart 代码。Isolate 之间通过消息传递进行通信，可以在不同</p>
<p>的 Isolate 之间发送和接收消息。</p>
<p><strong>并发执行</strong>：</p>
<p>I</p>
<p>solate 允许在同一个进程内同时执行多个任务，提高了应用程序的性能和响应性。</p>
<p>import ‘dart:isolate’;</p>
<p>void main(List<String> args) {</p>
<p>&#x2F;&#x2F; 开启一个并发线程</p>
<p>Isolate.spawn(cldc1, 1000000);</p>
<p>&#x2F;&#x2F; 开启一个并发线程</p>
<p>Isolate.spawn(cldc2, 100);</p>
<p>print(‘end’);</p>
<p>}</p>
<p>void cldc1(int count) {</p>
<p>int tolte &#x3D; 0;</p>
<p>for (int i &#x3D; 0; i &lt; count; i++) {</p>
<p>tolte &#x3D; tolte + i;</p>
<p>}</p>
<p>print(tolte);</p>
<p>}</p>
<p>void cldc2(int count) {</p>
<p>int tolte &#x3D; 0;</p>
<p>for (int i &#x3D; 0; i &lt; count; i++) {</p>
<p>tolte &#x3D; tolte + i;</p>
<p>}</p>
<p>print(tolte);</p>
<p>}<strong>隔离性</strong>：每个 Isolate 都有自己的内存空间，相互之间是隔离的，不会相互干扰。</p>
<p><strong>消息传递</strong>：Isolate 之间通过消息传递进行通信，可以在不同的 Isolate 之间共享数据和状态。</p>
<p><strong>控制粒度</strong>：Isolate 提供了细粒度的控制，可以单独启动、暂停、恢复和杀死 Isolate，实现更</p>
<p>灵活的并发控制。</p>
<p>Isolate 机制在 Dart 中广泛应用于实现多线程、并发执行和任务隔离。通过 Isolate，Dart 可</p>
<p>以在单个进程内实现高效的并发执行和内存隔离，提高应用程序的性能和可靠性。</p>
<p><strong>82****、</strong> <strong>Dart</strong> <strong>中的异步函数如何返回值</strong></p>
<p>在 Dart 中，实现异步有两种方法：1. 使用 async 和 await；2. 使用 Future API。下面是一个</p>
<p>使用 async 和 await 实现异步并返回值的示例代码：</p>
<p>import ‘dart:async’;</p>
<p>&#x2F;&#x2F; 异步函数</p>
<p>Future<int> fetchNumber() async {</p>
<p>&#x2F;&#x2F; 模拟异步操作</p>
<p>await Future.delayed(Duration(seconds: 2));</p>
<p>return 42;</p>
<p>}</p>
<p>void main() async {</p>
<p>&#x2F;&#x2F; 调用异步函数</p>
<p>int number &#x3D; await fetchNumber();</p>
<p>print(‘Fetched number: $number’);</p>
<p>}</p>
<p><strong>83****、 你如何在</strong> <strong>Flutter</strong> <strong>中进行数据分析和可视化？</strong></p>
<p>1、将数据发送到后端，并使用 Python 中的 pandas 或 Matplotlib 进行数据处理和可视化，</p>
<p>使用 webview 实现，webview 加载后的后端返回的图表实现数据分析和可视化</p>
<p>2、使用 flutter 图表插件实现</p>
<p><a target="_blank" rel="noopener" href="https://bruno.ke.com/page/widgets/brn-broken-line">https://bruno.ke.com/page/widgets/brn-broken-line</a></p>
<p><a target="_blank" rel="noopener" href="https://pub.dev/packages/fl_chart**84****%E3%80%81">https://pub.dev/packages/fl_chart**84****、</a>** <strong>Flutter</strong> <strong>开发中如何实现一套代码适配不同设备</strong></p>
<p>1、使用自适应布局，比如宽度使用自适应布局，Row 和 Column 里面结合 Expanded 实现自适应布局</p>
<p>2、通过百分比计算布局，达到自适应</p>
<p>3、使用 flutter_screenutil 按照设计稿还原设计稿</p>
<p>4、flutter_screenutil 底层是封装了 MediaQuery（媒体查询）实现的</p>
<p>5、根据不同终端的屏幕密度和分辨率，选择适当的字体大小和图像资源，以确保在各种设备上都能清晰显</p>
<p>示。</p>
<p>6、多台设备调试，布局的时候选择折中方案</p>
<p>7、不同平台的判断，比如 ios 和 android 有些差异可以通过平台判断实现不同的布局</p>
<p><strong>85****、</strong> <strong>Flutter</strong> <strong>中处理不同屏幕大小和设备类型的适配问题？</strong></p>
<p>同上</p>
<p><strong>86****、</strong> <strong>Flutter</strong> <strong>媒体查询</strong> <strong>MediaQuery</strong></p>
<p>flutter 提供了 MediaQuery.of(context)对象进行媒体查询, 具体使用方法查考下述例程</p>
<p>import ‘package:flutter&#x2F;material.dart’; </p>
<p>void main() &#x3D;&gt; runApp(MyApp()); </p>
<p>class MyApp extends StatefulWidget {</p>
<p>@override </p>
<p>_MyAppState createState() &#x3D;&gt; _MyAppState();</p>
<p>}</p>
<p>class _MyAppState extends State<MyApp> {</p>
<p>@override </p>
<p>Widget build(BuildContext context) { </p>
<p>return MaterialApp(</p>
<p>home: Scaffold( </p>
<p>appBar: AppBar(</p>
<p>title: Text(‘Device Info’), </p>
<p>),</p>
<p>body: FirstWidget(), </p>
<p>), </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p>class FirstWidget extends StatelessWidget {@override </p>
<p>Widget build(BuildContext context) { </p>
<p>return Column( </p>
<p>children: <Widget>[</p>
<p>Text(“设备像素逻辑像素 sp 大小:${MediaQuery.of(context).size}”),&#x2F;&#x2F;Size 类型</p>
<p>Text(“设备像素逻辑像素 sp 大小:${MediaQuery.of(context).padding}”), </p>
<p>Text(“每个逻辑像素的设备像素数:${MediaQuery.of(context).devicePixelRatio}”), </p>
<p>Text(“每个逻辑像素的字体像素数:${MediaQuery.of(context).textScaleFactor}”), </p>
<p>Text(“格式化时间时是否使用 24 小时格式:${MediaQuery.of(context).alwaysUse24HourFormat}”), </p>
<p>Text(“是横屏还是竖屏:${MediaQuery.of(context).orientation}”), </p>
<p>Text(“设备的亮度模式:${MediaQuery.of(context).platformBrightness}”), </p>
<p>Text(“被系统遮挡的部分(通常指键盘):${MediaQuery.of(context).viewInsets}”), </p>
<p>Text(“被系统遮挡的部分(常指“刘海屏”或系统状态栏):${MediaQuery.of(context).padding}”), </p>
<p>Text(“当前窗口的宽度和高度:${MediaQuery.of(context).systemGestureInsets}”), </p>
<p>Text(“当前窗口的宽度和高度:${MediaQuery.of(context).textScaleFactor}”), </p>
<p>], </p>
<p>);</p>
<p>}</p>
<p>}</p>
<p><strong>87****、</strong> <strong>Flutter</strong> <strong>实现响应式设计</strong></p>
<p>1、使用 MediaQuery：可以使用 MediaQuery 类来检索屏幕的大小（宽度&#x2F;高度）和方向（纵向&#x2F;横向）。每</p>
<p>当这些配置发生变化时，build 方法就会被调用，这确保 widget 树会被重建以反映最新的变化。</p>
<p>2、使用 AspectRatio：AspectRatio 是一个小部件，它会尝试将孩子的尺寸调整到一个特定的长宽比。小部</p>
<p>件首先尝试布局限制所允许的最大宽度，然后通过对宽度应用给定的长宽比来确定高度，表示为宽度与高</p>
<p>度的比率。</p>
<p>3、使用 FlutterScreenUtil：FlutterScreenUtil 是一个开源的 Flutter 库，它提供了一些方法来帮助开发者在不</p>
<p>同的屏幕大小和设备上实现响应式设计。</p>
<p><strong>88****、</strong> <strong>Flutter</strong> <strong>中</strong> <strong>Widget<strong><strong>、</strong></strong>Element<strong><strong>、</strong></strong>RenderObject</strong> <strong>三者之间的</strong></p>
<p><strong>关系</strong></p>
<p>Widget 定义了应用程序的 UI，Element 是 Widget 的实例化，保存了 Widget 树的状态，</p>
<p>而 RenderObject 则是实际负责在屏幕上绘制 UI 的对象</p>
<p><strong>Widget</strong>：是 Flutter 应用中的基础构建块，是一个配置的描述，它定义了应用程序的 UI 部</p>
<p>分，例如文本、行、列等。Widgets 本身并不是 UI，它们更像是告诉 Flutter 框架应该如何</p>
<p>构建 UI 的蓝图。</p>
<p><strong>Element</strong>：是 Widget 的实例化。当一个 Widget 被放置到树中时，它会被一个对应的Element 所包裹。Element 对象是持久的，它保存了 Widget 树的状态。当 Widget 的配置</p>
<p>发生变化时，Element 会比较新旧 Widgets，并决定是否需要更新界面。</p>
<p><strong>RenderObject</strong>：是负责具体的绘制操作的对象。它知道如何在屏幕上渲染自己，处理布局和</p>
<p>大小调整。每个 Element 都会关联一个 RenderObject，当 Element 的状态发生变化时，对</p>
<p>应的 RenderObject 会进行重新绘制。这是实际负责在屏幕上绘制 UI 的对象。它们处理布</p>
<p>局和绘图逻辑。</p>
<p><strong>89****、</strong> <strong>flutter</strong> <strong>代码的版本控制是如何实现的</strong></p>
<p>flutter 代码的版本控制可以使用 git 或者 svn 实现，会什么说什么</p>
<p>好处就是可以实现分支管理、版本号管理、团队协作</p>
<p><strong>90<strong><strong>、</strong></strong>Flutter</strong> <strong>中如何进行进行代码重构和维护</strong></p>
<p>1、按照公司市场部门的需求增加新功能或者删除一些功能</p>
<p>2、项目进行模块划分和组件化，方便功能的增加</p>
<p>3、将重复的代码片段提取为独立的函数或方法，以提高代码的可读性和可维护性</p>
<p>4、注意代码程序的性能并进行必要的优化</p>
<p>5、为关键代码添加文档注释，解释代码的功能和逻辑</p>
<p>6、跟进 Flutter 的更新：及时了解 Flutter 的新版本和最佳实践，将新的特性和改进应用</p>
<p>到项目中。</p>
<p><strong>91****、在</strong> <strong>Flutter</strong> <strong>中如何处理音频和视频播放</strong></p>
<p>Flutter 中，你可以使用各种插件来实现音频和视频的播放功能。</p>
<p>例如，使用 text_to_speech 插件来将文字转换为语音，使用内置的 video_player 插件实现视</p>
<p>频播放，或者使用 audioplayers 插件实现音频播放。如果你只需要一个简单的播放器，也</p>
<p>可以使用第三方插件 chewie 来实现。</p>
<p><strong>92****、如何在</strong> <strong>Flutter</strong> <strong>中处理用户输入和交互</strong></p>
<p>1、使用 GestureDetector 组件：GestureDetector 允许你检测用户的触摸手势，如点击、滑</p>
<p>动、长按等。你可以通过在组件中嵌套 GestureDetector 来响应这些手势。</p>
<p>2、处理文本输入：如果需要用户输入文本，可以使用 TextField 或 TextFormField 组件。这</p>
<p>些组件提供了输入框，并且可以监听用户的输入变化。</p>
<p>3、使用按钮：通过创建 RaisedButton、FlatButton 或其他按钮类型，用户可以点击按钮来</p>
<p>触发交互操作。4、监听事件：Flutter 中的许多组件都提供了事件监听器，例如 onTap、onPressed 等。你</p>
<p>可以在相应的组件上添加这些监听器来响应特定的用户操作。</p>
<p>5、使用 ScrollController 处理滚动：如果你的界面包含可滚动内容，例如列表或滚动视图，</p>
<p>可以使用 ScrollController 来管理滚动行为并响应滚动事件。</p>
<p>6、响应设备方向变化：如果你的应用支持横竖屏切换，可以使用 OrientationBuilder 或</p>
<p>MediaQuery 来根据设备方向进行布局和交互的调整。</p>
<p>7、调用插件和原生交互</p>
<p><strong>93<strong><strong>、</strong></strong>Flutter</strong> <strong>中使用机器学习和人工智能技术</strong></p>
<p>Flutter 本身并不直接提供机器学习和人工智能相关的功能，可以调用后端接口或者使用插</p>
<p>件实现，使用 text_to_speech 插件来将文字转换为语音，使用 speech_to_text 把语音转换成</p>
<p>文字，比如 Flutter 结合 Baidu Ai 实现 拍照识别文字</p>
<p><strong>94****、如何在</strong> <strong>Flutter</strong> <strong>中使用原生平台的功能和服务</strong></p>
<p>Flutter 中使用原生平台的功能和服务，可以通过以下几种方式实现：</p>
<p>1、使用 Flutter 官方和社区的插件实现，Flutter 目前已经非常成熟了，插件市场有上百万个</p>
<p>插件。可以在 pub.dev 上搜索并安装适合自己需求的插件。</p>
<p>2、自己开发插件：如果没有找到满足需求的现成插件，你可以自己开发插件。通过使用</p>
<p>Flutter 的 平 台 通 道 和 原 生 开 发 语 言 （ 如 </p>
<p>Android 的 </p>
<p>Java&#x2F;Kotlin 或 </p>
<p>iOS 的</p>
<p>Objective-C&#x2F;Swift），可以将原生平台的功能集成到 Flutter 应用中。</p>
<p><strong>95****、如何在</strong> <strong>Flutter</strong> <strong>中进行代码混淆和加密</strong></p>
<p>1、Flutter 正式打包后资源已经被加密了，正常是不需要我们自己处理代码混淆和加密的</p>
<p>2、如果你的应用中包含敏感的图片、音频或其他资源文件，可以考虑对这些资源进行加密。</p>
<p>你可以使用加密算法来加密资源文件，并在应用运行时进行解密</p>
<p>3、API 加密：对于与后端服务交互的 API，可以使用加密技术来保护数据的传输和访问3、如果公司有特殊要求，可以使用代码混淆工具来改变代码的结构和命名。过度的混淆可</p>
<p>能会影响应用的性能和可维护性，因此需要在安全性和可维护性之间进行平衡</p>
<p><strong>96****、你在</strong> <strong>Flutter</strong> <strong>项目中承担的角色和工作职责。</strong></p>
<p><strong>需求分</strong>析：参与需求分析和 UI 设计讨论</p>
<p><strong>功能实现：</strong>根据项目需求，搭建框架实现共建</p>
<p><strong>代码优化</strong>：注重代码的性能优化，通过合理的布局和渲染策略，提高应用的流畅性和响应速</p>
<p>度。</p>
<p><strong>问题解决</strong>：在开发过程中，调试和解决遇到的问题，包括排查错误、优化性能瓶颈等。</p>
<p><strong>与团队协作</strong>：与团队成员密切合作，分享技术知识，参与代码审查，提供技术建议和改进方</p>
<p>案。</p>
<p><strong>测试与质量保证</strong>：参与编写和执行测试用例，确保应用的质量和稳定性，修复发现的缺陷。</p>
<p><strong>持续学习</strong>：保持对 Flutter 最新技术和趋势的关注，不断学习和提升自己的技能，将新的知</p>
<p>识应用到项目中。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2024/07/31/flutter知识点总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Anh Tinh</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/22/flutter3-x%E4%BB%BF%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8Eapp/" title="flutter3.x仿小米商城app">
                        <span class="hidden-mobile">flutter3.x仿小米商城app</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
